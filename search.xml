<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux下安装配置MatlabR2019</title>
      <link href="/2022/05/30/Linux%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMatlabR2019/"/>
      <url>/2022/05/30/Linux%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMatlabR2019/</url>
      
        <content type="html"><![CDATA[<p>Linux下安装Matlab并解决常见问题</p><span id="more"></span><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://pan.baidu.com/s/1I4mc4eQtvn5ZATjgg8rFaQ?pwd=iyka">百度网盘(Matlab R2019b Linux)</a></p><p>下载其中的两个文件，一个是安装镜像，另一个是破解文件</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir /mnt/matlab</span><br><span class="line">mount ./R2019b_Linux.iso /mnt/matlab</span><br></pre></td></tr></table></figure><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /mnt/matlab/install</span><br></pre></td></tr></table></figure><p>选择离线激活，然后开始安装，需要序列号时输入序列号</p><p><code>09806-07443-53955-64350-21751-41297</code></p><blockquote><p>如果安装界面有中文显示不正常，可以先不去管，等到安装完成再去处理</p></blockquote><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>解压<code>Matlab R2019b Linux64 Crack.tar.gz</code>,找到<code>license_standalone.lic</code>文件</p><p>更改权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 ./license_standalone.lic</span><br></pre></td></tr></table></figure><p>复制破解文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir 安装目录/licenses</span><br><span class="line">sudo cp ./license_standalone.lic 安装目录/licenses/</span><br><span class="line">sudo cp -r ./R2019b/bin 安装目录/</span><br></pre></td></tr></table></figure><h3 id="尝试运行"><a href="#尝试运行" class="headerlink" title="尝试运行"></a>尝试运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">安装目录/bin/matlab</span><br></pre></td></tr></table></figure><p>此时会报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATLAB is selecting SOFTWARE OPENGL rendering.                            </span><br><span class="line">/opt/matlab/bin/glnxa64/MATLAB: error while loading shared libraries: libcrypt.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>根据<a href="https://www.mathworks.com/matlabcentral/answers/473294-why-do-i-see-the-error-error-while-loading-shared-libraries-libcrypt-so-1-when-starting-matlab-on">Mathworks</a>的解答，需要安装<code>libxcrypt-compat</code>软件包，原本这一软件包在AUR,现在AUR已经搜不到这个包了，可以直接在官方仓库安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S libxcrypt-compat</span><br></pre></td></tr></table></figure><p>安装成功之后，再次尝试打开，即可正常启动了。</p><h2 id="添加应用程序图标"><a href="#添加应用程序图标" class="headerlink" title="添加应用程序图标"></a>添加应用程序图标</h2><p>matlab不会自动创建应用程序图标，需要手动创建</p><p>在<code>/usr/share/applications/</code>目录下创建<code>matlab.desktop</code>文件，写入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">Terminal=false</span><br><span class="line">MimeType=text/x-matlab</span><br><span class="line">Exec=安装目录/bin/matlab -desktop</span><br><span class="line">Name=MATLAB</span><br><span class="line">Icon=matlab</span><br><span class="line">Categories=Development;Math;Science</span><br><span class="line">Comment=Scientific computing environment</span><br><span class="line">StartupNotify=true</span><br></pre></td></tr></table></figure><p>保存退出就可以看到创建了应用程序图标</p><h2 id="解决常见问题"><a href="#解决常见问题" class="headerlink" title="解决常见问题"></a>解决常见问题</h2><h3 id="中文字体"><a href="#中文字体" class="headerlink" title="中文字体"></a>中文字体</h3><p>遇到matlab中文显示异常，一般是字体的问题，参考<a href="https://blog.csdn.net/weixin_30588427/article/details/115879282">matlab 汉字是方块,linux下Matlab 2020中文字体方框问题解决方法</a>解决</p><p>下载支持中文的等宽字体<br><a href="https://github.com/crvdgc/Consolas-with-Yahei">Consolas-with-Yahei</a><br>安装为系统字体，实测直接在matlab设置中切换为该字体之后重启即可，如果不行再根据<a href="https://blog.csdn.net/weixin_30588427/article/details/115879282">matlab 汉字是方块,linux下Matlab 2020中文字体方框问题解决方法</a>步骤来操作</p><h3 id="菜单栏缩放"><a href="#菜单栏缩放" class="headerlink" title="菜单栏缩放"></a>菜单栏缩放</h3><p>在高分屏下，菜单栏字体很小，看起来很难受，可以根据<a href="https://blog.csdn.net/zwhut/article/details/79779174">解决Ubuntu高分屏下matlab标题栏（菜单栏）字体过小问题</a>提供的方法来解决</p><p>在matlab中的命令行窗口执行如下两条命令</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">s = settings;s.matlab.desktop.DisplayScaleFactor</span><br><span class="line">s.matlab.desktop.DisplayScaleFactor.PersonalValue = <span class="number">1.5</span></span><br></pre></td></tr></table></figure><blockquote><p>最后的1.5是缩放倍数，可以根据实际情况进行调节</p></blockquote><p>重启matlab之后可以看到，缩放变得正常了。</p><h3 id="Simulink启动报错"><a href="#Simulink启动报错" class="headerlink" title="Simulink启动报错"></a>Simulink启动报错</h3><p>报错信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">警告: MATLABWindow 应用程序未能启动。Unable to</span><br><span class="line">launch the MATLABWindow application </span><br><span class="line">&gt; In sltemplate.ui/StartPage/showWithFallback</span><br><span class="line">  In sltemplate.ui/StartPage/show</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.mathworks.com/matlabcentral/answers/364551-why-is-matlab-unable-to-run-the-matlabwindow-application-on-linux">Why is MATLAB unable to run the MATLABWindow application on Linux?</a>提供的解决方案</p><p>在matlab命令行中执行</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">cd(matlabroot)</span><br><span class="line">! bin/glnxa64/MATLABWindow</span><br></pre></td></tr></table></figure><p>查看报错信息，根据报错信息分别处理</p><p>如：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">bin/glnxa64/MATLABWindow: path to/libstdc++.so<span class="number">.6</span>: version `CXXABI_1<span class="number">.3</span><span class="number">.9</span>&#x27; not found (required by _somelibrary_)</span><br></pre></td></tr></table></figure><p>看到形如这样的报错，就需要去<code>安装目录/sys/os/glnxa64</code>目录下去处理<code>libstdc++.so.6</code>文件</p><p>具体操作如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 安装目录/sys/os/glnxa64</span><br><span class="line">sudo mkdir exclude</span><br><span class="line">sudo mv libstdc++.so.6* exclude/</span><br></pre></td></tr></table></figure><p>如此反复测试，根据文章内容列出的几种情况分别处理，知道不再报错即可。</p><blockquote><p>注意，不同情况需要处理的库文件在不同的目录，要仔细阅读注意分辨。</p></blockquote><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>至此matlab基本功能均可正常使用。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Linux下qtcreator无法输入中文的问题</title>
      <link href="/2022/02/08/%E8%A7%A3%E5%86%B3Linux%E4%B8%8Bqtcreator%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/08/%E8%A7%A3%E5%86%B3Linux%E4%B8%8Bqtcreator%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在Ubuntu上安装fcitx5之后发现，QtCreator无法输入中文了。</p><span id="more"></span><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>由于Ubuntu下Qtcreator默认只支持了ibus,所以新安装fcitx5或者fcitx无法在qtcreator中输入中文。</p><p>需要自己手动编译fcitx5官方的qt插件</p><p><a href="https://github.com/fcitx/fcitx-qt5">官方仓库</a>：<a href="https://github.com/fcitx/fcitx-qt5">https://github.com/fcitx/fcitx-qt5</a></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>github上还有一个仓库叫fcitx5-qt,千万不要编译这个，两个仓库差不多，我也不知道区别，但是实测这个仓库编译之后不能解决问题。</p><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/fcitx/fcitx-qt5</span><br><span class="line"><span class="built_in">cd</span> fcitx-qt</span><br></pre></td></tr></table></figure><h3 id="修改CMakeLists-txt文件"><a href="#修改CMakeLists-txt文件" class="headerlink" title="修改CMakeLists.txt文件"></a>修改CMakeLists.txt文件</h3><p><strong>注意！要根据实际情况来改，看你的qtcreator是用什么版本的qt编译的</strong></p><p>在qtcreator-帮助-aboutqtcreator中查看</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20220208205639939.png" alt="image-20220208205639939"></p><p>如果是qt5编译的，则在CMakeLists.txt中找到</p><p><code>option(ENABLE_QT5 &quot;Enable Qt5&quot; Off)</code>改为<code>option(ENABLE_QT5 &quot;Enable Qt5&quot; On)</code></p><p>如果是qt5编译的，则在CMakeLists.txt中找到</p><p><code>option(ENABLE_QT5 &quot;Enable Qt6 im module&quot; Off)</code>改为<code>option(ENABLE_QT5 &quot;Enable Qt6 im module&quot; On)</code></p><h3 id="创建编译目录"><a href="#创建编译目录" class="headerlink" title="创建编译目录"></a>创建编译目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure><h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><p>在build目录下编译</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake .. -DCMAKE_PREFIX_PATH=qt安装目录/6.2.3/gcc_64 -DENABLE_LIBRARY=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>config成功之后直接</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>编译完成之后，可以在build目录下找到<code>qt6/platforminputcontext/libfcitxplatforminputcontextplugin-qt6.so</code></p><p>这就是我们要的文件</p><p>把他复制到这两个地方：</p><ol><li>qt安装目录/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts(qtcreator就可以输入中文了)</li><li>qt安装目录/6.2.3/gcc_64/plugins/platforminputcontexts(你用qt6编译的程序中就可以输入中文了)</li></ol>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QtCreator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用CDN加速的Github作为图床</title>
      <link href="/2021/12/15/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%9A%84Github%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2021/12/15/%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E7%9A%84Github%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p>使用CDN加速的Github作为图床。</p><span id="more"></span><blockquote><p>本文全部图片均使用CDN加速的GitHub作为图床</p></blockquote><p>写博客免不了要用到图床，想要搭建免费的图床，一般就两个选择，github或者gitee，但是这二者各自有各自的优缺点，gitee由于是国内的，访问速度快，但是空间限制比较大，而且单个图片的大小限制也很难受，github虽然没有这些限制，但是由于种种原因，访问速度非常慢。</p><p>为了解决这个问题，我们可以使用CDN加速的github作为图床。</p><p>访问<a href="https://www.jsdelivr.com/">jsDelivr - A free, fast, and reliable CDN for open source</a>可以看到，这个网站提供对GitHub的CDN加速服务：</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211216104925942.png" alt="image-20211216104925942"></p><p>只要按照这一格式访问你的github仓库中的资源，访问速度就会非常快：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/用户名/仓库名/文件路径</span><br></pre></td></tr></table></figure><p>这样一来，我们就可以把github作为图床，然后使用图片时使用这样的链接就可以了。</p><h1 id="使用PicGo"><a href="#使用PicGo" class="headerlink" title="使用PicGo"></a>使用PicGo</h1><p>为了方便上传图片到图床，可以下载PicGo，全平台支持，非常方便。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211216105305955.png" alt="image-20211216105305955"></p><p>要在PicGo中使用Github作为图床，需要手动设置。</p><p>填写如下选项：</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211216105511591.png" alt="image-20211216105511591"></p><ul><li>仓库名就是新建的作为图床仓库名称，注意格式：用户名/仓库名</li><li>分支名默认为main</li><li>Token需要到GitHub的setting中生成，权限只需要勾选repo</li></ul><p>即可</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211216105739131.png" alt="image-20211216105739131"></p><p>最后，需要设置自定义域名为<code>https://cdn.jsdelivr.net/gh/用户名/仓库名</code>,这样默认复制的图片链接就是经过CDN加速的链接了。</p><p>设置完成后即可测试上传图片了。</p><h1 id="使用Typora"><a href="#使用Typora" class="headerlink" title="使用Typora"></a>使用Typora</h1><p>使用Typora编写MarkDown时，为了方便的插入图片，可以在设置中开启图片自动上传。使用这一功能的前提是已经配置好了PicGo。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211216110150350.png" alt="image-20211216110150350"></p><p>设置好PicGo路径之后，验证图片上传选项，上传成功就可以开始使用了，这样设置之后，在编写MarkDown时，只要将图片直接在文章中粘贴，就可以自动上传然后生成MarkDown格式的链接，非常方便。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211216110425381.png" alt="image-20211216110425381"></p><h1 id="使用utools"><a href="#使用utools" class="headerlink" title="使用utools"></a>使用utools</h1><p>有时候不需要在MarkDown中插入，只是单纯的需要获取上传后的链接，可以直接复制后按PicGo的快捷键Ctrl+Shift+P，但这个快捷键还是不太方便，可以编写utools的自动化脚本：</p><p>在utools中按照插件<code>自动化助手</code></p><p>打开后点击我的自动化，新建自动化</p><p>编写如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ENTER.type === <span class="string">&#x27;files&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!utools.copyImage(ENTER.payload[<span class="number">0</span>].path)) <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">utools.simulateKeyboardTap(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;ctrl&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后设置关键字：</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211216110844499.png" alt="image-20211216110844499"></p><p>保存后就可以使用了</p><p>使用方法：</p><ol><li>截图后复制到剪切板，按对应按键呼出utools超级面板后点击上传到图床：<br><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211216111016011.png" alt="image-20211216111016011"></li><li>在资源管理器中点击图片文件，然后呼出utools超级面板，点击上传到图床：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211216111211581.png" alt="image-20211216111211581"></p><p>至此就可以愉快的使用Github作为图床啦！</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> picgo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下Aria2下载器最佳配置</title>
      <link href="/2021/12/11/Windows%E4%B8%8BAria2%E4%B8%8B%E8%BD%BD%E5%99%A8%E6%9C%80%E4%BD%B3%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/12/11/Windows%E4%B8%8BAria2%E4%B8%8B%E8%BD%BD%E5%99%A8%E6%9C%80%E4%BD%B3%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>Windows下Aria2下载器最佳配置</p><span id="more"></span><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>最好不要在乱七八糟的地方下载别人打包的，就用官方的自己配置就好。</p><p>在github下载最新版：</p><p><a href="https://github.com/aria2/aria2/releases">aria2下载地址</a></p><p>软件不需要安装，下载好之后直接解压到自己要安装的目录即可</p><h1 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h1><p>在安装目录下新建两个文件：</p><p>会话文件<code>aria2.session</code>,建立空文件即可。</p><p>配置文件<code>aria2.conf</code>:</p><p>填入如下内容，可以根据需求自己更改，主要就改</p><ul><li>会话文件路径：<code>input-file</code>和<code>save-session</code>,根据实际情况填写。</li><li>默认下载路径：<code>dir</code></li><li>访问密钥：<code>rpc-secret</code>,也就是一些地方连接时候需要的token。</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## &#x27;#&#x27;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ##</span></span><br><span class="line"><span class="comment">## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释  ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 进度保存相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从会话文件中读取下载任务</span></span><br><span class="line"><span class="string">input-file=D:\SoftWares\Aria2\aria2.session</span></span><br><span class="line"><span class="comment"># 在Aria2退出时保存`错误/未完成`的下载任务到会话文件</span></span><br><span class="line"><span class="string">save-session=D:\SoftWares\Aria2\aria2.session</span></span><br><span class="line"><span class="comment"># 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span></span><br><span class="line"><span class="comment">#save-session-interval=60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 文件保存相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件的保存路径, 默认: 当前启动位置</span></span><br><span class="line"><span class="string">dir=D:\Dir\download</span></span><br><span class="line"><span class="comment"># 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span></span><br><span class="line"><span class="comment">#disk-cache=32M</span></span><br><span class="line"><span class="comment"># 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span></span><br><span class="line"><span class="comment"># 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span></span><br><span class="line"><span class="comment"># falloc和trunc则需要文件系统和内核支持</span></span><br><span class="line"><span class="comment"># NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项</span></span><br><span class="line"><span class="comment">#file-allocation=none</span></span><br><span class="line"><span class="comment"># 断点续传</span></span><br><span class="line"><span class="string">continue=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 下载连接相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大同时下载任务数, 运行时可修改, 默认:5</span></span><br><span class="line"><span class="comment">#max-concurrent-downloads=5</span></span><br><span class="line"><span class="comment"># 同一服务器连接数, 添加时可指定, 默认:1</span></span><br><span class="line"><span class="string">max-connection-per-server=16</span></span><br><span class="line"><span class="comment"># 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span></span><br><span class="line"><span class="comment"># 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span></span><br><span class="line"><span class="string">min-split-size=10M</span></span><br><span class="line"><span class="comment"># 单个任务最大线程数, 添加时可指定, 默认:5</span></span><br><span class="line"><span class="string">split=32</span></span><br><span class="line"><span class="comment"># 整体下载速度限制, 运行时可修改, 默认:0</span></span><br><span class="line"><span class="comment">#max-overall-download-limit=0</span></span><br><span class="line"><span class="comment"># 单个任务下载速度限制, 默认:0</span></span><br><span class="line"><span class="comment">#max-download-limit=0</span></span><br><span class="line"><span class="comment"># 整体上传速度限制, 运行时可修改, 默认:0</span></span><br><span class="line"><span class="comment">#max-overall-upload-limit=0</span></span><br><span class="line"><span class="comment"># 单个任务上传速度限制, 默认:0</span></span><br><span class="line"><span class="comment">#max-upload-limit=0</span></span><br><span class="line"><span class="comment"># 禁用IPv6, 默认:false</span></span><br><span class="line"><span class="comment">#disable-ipv6=true</span></span><br><span class="line"><span class="comment"># 连接超时时间, 默认:60</span></span><br><span class="line"><span class="comment">#timeout=60</span></span><br><span class="line"><span class="comment"># 最大重试次数, 设置为0表示不限制重试次数, 默认:5</span></span><br><span class="line"><span class="comment">#max-tries=5</span></span><br><span class="line"><span class="comment"># 设置重试等待的秒数, 默认:0</span></span><br><span class="line"><span class="comment">#retry-wait=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## RPC相关设置 ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用RPC, 默认:false</span></span><br><span class="line"><span class="string">enable-rpc=true</span></span><br><span class="line"><span class="comment"># 允许所有来源, 默认:false</span></span><br><span class="line"><span class="string">rpc-allow-origin-all=true</span></span><br><span class="line"><span class="comment"># 允许非外部访问, 默认:false</span></span><br><span class="line"><span class="string">rpc-listen-all=true</span></span><br><span class="line"><span class="comment"># 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同</span></span><br><span class="line"><span class="comment">#event-poll=select</span></span><br><span class="line"><span class="comment"># RPC监听端口, 端口被占用时可以修改, 默认:6800</span></span><br><span class="line"><span class="comment">#rpc-listen-port=8280</span></span><br><span class="line"><span class="comment"># 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span></span><br><span class="line"><span class="string">rpc-secret=666666</span></span><br><span class="line"><span class="comment"># 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span></span><br><span class="line"><span class="comment">#rpc-user=&lt;USER&gt;</span></span><br><span class="line"><span class="comment"># 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span></span><br><span class="line"><span class="comment">#rpc-passwd=&lt;PASSWD&gt;</span></span><br><span class="line"><span class="comment"># 是否启用 RPC 服务的 SSL/TLS 加密,</span></span><br><span class="line"><span class="comment"># 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接</span></span><br><span class="line"><span class="comment">#rpc-secure=true</span></span><br><span class="line"><span class="comment"># 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,</span></span><br><span class="line"><span class="comment"># 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥</span></span><br><span class="line"><span class="comment">#rpc-certificate=/path/to/certificate.pem</span></span><br><span class="line"><span class="comment"># 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件</span></span><br><span class="line"><span class="comment">#rpc-private-key=/path/to/certificate.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## BT/PT下载相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true</span></span><br><span class="line"><span class="comment">#follow-torrent=true</span></span><br><span class="line"><span class="comment"># BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999</span></span><br><span class="line"><span class="string">listen-port=51413</span></span><br><span class="line"><span class="comment"># 单个种子最大连接数, 默认:55</span></span><br><span class="line"><span class="comment">#bt-max-peers=55</span></span><br><span class="line"><span class="comment"># 打开DHT功能, PT需要禁用, 默认:true</span></span><br><span class="line"><span class="string">enable-dht=false</span></span><br><span class="line"><span class="comment"># 打开IPv6 DHT功能, PT需要禁用</span></span><br><span class="line"><span class="comment">#enable-dht6=false</span></span><br><span class="line"><span class="comment"># DHT网络监听端口, 默认:6881-6999</span></span><br><span class="line"><span class="comment">#dht-listen-port=6881-6999</span></span><br><span class="line"><span class="comment"># 本地节点查找, PT需要禁用, 默认:false</span></span><br><span class="line"><span class="comment">#bt-enable-lpd=false</span></span><br><span class="line"><span class="comment"># 种子交换, PT需要禁用, 默认:true</span></span><br><span class="line"><span class="string">enable-peer-exchange=false</span></span><br><span class="line"><span class="comment"># 每个种子限速, 对少种的PT很有用, 默认:50K</span></span><br><span class="line"><span class="comment">#bt-request-peer-speed-limit=50K</span></span><br><span class="line"><span class="comment"># 客户端伪装, PT需要</span></span><br><span class="line"><span class="string">peer-id-prefix=-TR2770-</span></span><br><span class="line"><span class="string">user-agent=Transmission/2.77</span></span><br><span class="line"><span class="comment"># 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0</span></span><br><span class="line"><span class="string">seed-ratio=0</span></span><br><span class="line"><span class="comment"># 强制保存会话, 即使任务已经完成, 默认:false</span></span><br><span class="line"><span class="comment"># 较新的版本开启后会在任务完成后依然保留.aria2文件</span></span><br><span class="line"><span class="comment">#force-save=false</span></span><br><span class="line"><span class="comment"># BT校验相关, 默认:true</span></span><br><span class="line"><span class="comment">#bt-hash-check-seed=true</span></span><br><span class="line"><span class="comment"># 继续之前的BT任务时, 无需再次校验, 默认:false</span></span><br><span class="line"><span class="string">bt-seed-unverified=true</span></span><br><span class="line"><span class="comment"># 保存磁力链接元数据为种子文件(.torrent文件), 默认:false</span></span><br><span class="line"><span class="string">bt-save-metadata=true</span></span><br></pre></td></tr></table></figure><h1 id="开机后台运行"><a href="#开机后台运行" class="headerlink" title="开机后台运行"></a>开机后台运行</h1><p>在安装目录新建<code>start.vbs</code>文件，右键编辑填写以下内容：</p><figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CreateObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>).Run <span class="string">&quot;D:\Softwares\Aria2\aria2c.exe --conf-path=D:\Softwares\Aria2\aria2.conf&quot;</span>,<span class="number">0</span>,<span class="literal">True</span></span><br></pre></td></tr></table></figure><p>注意更改其中的<code>aria2c.exe</code>与<code>aria2.conf</code>的实际路径。</p><p>然后将这一文件复制到<code>C:\Users\用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\</code>目录下即可开机启动，注意该脚本有可能会被杀毒软件删除，要将其添加到白名单。</p><h1 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h1><p>由于aria2是在后台运行的，为了方便查看下载进度，可以安装一个浏览器插件：</p><p>edge：<a href="https://microsoftedge.microsoft.com/addons/detail/aria2-for-edge/jjfgljkjddpcpfapejfkelkbjbehagbh">安装地址</a></p><p>chrome：<a href="https://www.extfans.com/productivity/mpkodccbngfoacfalldjimigbofkhgjn/">下载地址</a></p><p>安装完成后对扩展进行一些设置：</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211211170918454.png" alt="image-20211211170918454"></p><p>完成后保存，插件图标如果是这样说明连接成功：<img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211211171017386.png" alt="image-20211211171017386"></p><p>到此aria2下载器配置完成，可以完全接管浏览器下载任务，在使用某些网盘脚本时也可以一键发送到aria2进行下载。</p><p>下载文件测试：</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211211171614891.png" alt="image-20211211171614891"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aria2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS code + clangd + Clang + CMAKE配置C/C++开发环境</title>
      <link href="/2021/12/10/CMAKE%E9%85%8D%E7%BD%AEC-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2021/12/10/CMAKE%E9%85%8D%E7%BD%AEC-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>结合B站大佬的方法，不用WSL在vscode中配置C/C++开发环境</p><span id="more"></span><p>参考B站up主的视频<a href="https://www.bilibili.com/video/BV1sW411v7VZ">使用 VS Code + Clangd + CMake 搭建 C/C++开发环境</a>来进行配置。</p><p>B站大佬的配置方法很好，但是在Windows下用WSL来进行开发终究还是有点麻烦，而且wsl运行的内存占用，快赶上一些大型IDE了，这样的话配置vscode不就没有必要了吗，为什么不直接使用Clion或者VS呢。</p><p>所以找到这些软件尝试不用WSL在windows下配置C/C++开发环境，但最后发现虽然LLVM有windows版本，但是要用到Visual Studio，<del>于是放弃clang，直接用MinGW来配置。</del></p><p>今天偶尔发现一个网站<a href="https://winlibs.com/">winlibs</a>，提供默认不使用MSVC的Clang版本，下载试了试，真的是太香了。</p><p><em><strong>这样一来就可以不用WSL，完美在windows本地实现B站大佬的开发环境配置</strong></em></p><h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><p>用到的软件/插件(直接点击链接下载安装即可)：</p><p>软件：</p><ul><li><a href="https://code.visualstudio.com/">Visual Studio Code</a></li><li><a href="https://cmake.org/download/">CMake</a></li><li><del><a href="https://www.mingw-w64.org/downloads/">MinGW</a></del>(可以直接用打包好的LLVM就不用下载MinGW了)</li><li><a href="https://winlibs.com/">LLVM</a></li><li><a href="https://github.com/ninja-build/ninja/releases">Ninja</a></li></ul><p>插件：</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">CMake Tools</a></li><li><a href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd">clangd</a></li><li><a href="https://github.com/vadimcn/vscode-lldb/releases">CodeLLDB</a></li></ul><p>某些官网或者github上不去可以直接在蓝奏云下载：</p><p><a href="https://wwd.lanzouo.com/b02olvw6h">打包下载地址</a></p><p>密码:9uaq</p><h2 id="安装vscode"><a href="#安装vscode" class="headerlink" title="安装vscode"></a>安装vscode</h2><p>一路next</p><h2 id="安装cmake"><a href="#安装cmake" class="headerlink" title="安装cmake"></a>安装cmake</h2><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211210172019994.png" alt="image-20211210172019994"></p><p>下载<code>.msi</code>格式的安装包来安装。</p><p>注意安装时勾选将cmake添加到path。</p><h2 id="安装编译器"><a href="#安装编译器" class="headerlink" title="安装编译器"></a>安装编译器</h2><p>到<a href="https://winlibs.com/">winlibs</a>直接下载，按网站的说法这个打包在windows下提供了完整的编译器环境。</p><p>至于下载哪个版本，可以参照网站的说明。</p><blockquote><p>Traditionally the MinGW-w64 compiler used MSVCRT as runtime library, which is available on all versions of Windows.</p><p>Since Windows 10 Universal C Runtime (UCRT) is available as an alternative to MSVCRT. Universal C Runtime can also be installed on earlier versions of Windows (see: <a href="https://support.microsoft.com/en-us/topic/update-for-universal-c-runtime-in-windows-c0514201-7fe6-95a3-b0a5-287930f3560c">Update for Universal C Runtime in Windows</a>).</p><p>Unless you are targetting older versions of Windows, UCRT as runtime library is the better choice, as it was written to better support recent Windows versions as well as provide better standards conformance (see also: <a href="https://docs.microsoft.com/en-us/cpp/porting/upgrade-your-code-to-the-universal-crt?view=msvc-160">Upgrade your code to the Universal CRT</a>).</p></blockquote><p>大概意思就是说，首选下载ucrt版本。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211216222317595.png" alt="image-20211216222317595"></p><p>下载对应的包含LLVM的版本。</p><p>由于网站好像是在github托管的，可能会有上不去或者下载慢的问题，可以下载我存在网盘的：<a href="https://pan.baidu.com/s/1l-xWd83b_836LJbYM68gSA">百度网盘</a> 提取码: uppb </p><p>下载完成后，直接解压到要安装的路径下，再将其中的<code>bin</code>文件夹添加到环境变量即可。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211216223133463.png" alt="image-20211216223133463"></p><h2 id="安装Ninja"><a href="#安装Ninja" class="headerlink" title="安装Ninja"></a>安装Ninja</h2><p>下载之后将文件夹解压到一个固定位置之后，将文件夹添加到环境变量即可，由于是cmake在用，也可以直接把<code>ninja.exe</code>直接放到cmake安装目录下的<code>bin</code>文件夹下,就不用单独添加环境变量了。</p><h2 id="安装clangd"><a href="#安装clangd" class="headerlink" title="安装clangd"></a>安装clangd</h2><p>由于winlibs打包的编译器中有与之匹配的clangd，就在<code>bin</code>文件夹中，所以不需要单独安装，直接用即可。</p><h2 id="安装vscode插件"><a href="#安装vscode插件" class="headerlink" title="安装vscode插件"></a>安装vscode插件</h2><p>vscode中的插件，CMake Tools和clangd可以直接在vscode中搜索安装，没有问题，只是clangd与C/C++插件不兼容，要注意不要安装C/C++插件。</p><p>对于CodeLLDB，在vscode中安装大概率会下载失败，可以直接到github页面去下载<code>.vsix</code>文件手动安装.</p><h3 id="安装方法："><a href="#安装方法：" class="headerlink" title="安装方法："></a>安装方法：</h3><p>打开vscode，按F1，输入vsix，出现从VSIX安装，点击后选择下载的<code>.vsix</code>文件即可安装成功。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211210173926386.png" alt="image-20211210173926386"></p><h1 id="配置C-C-项目"><a href="#配置C-C-项目" class="headerlink" title="配置C/C++项目"></a>配置C/C++项目</h1><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>新建一个文件夹作为项目目录，在目录下新建几个文件：</p><p>目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├─src</span><br><span class="line">│  ├─Template.c</span><br><span class="line">│  └─Template.h</span><br><span class="line">├─CMakeLists.txt</span><br><span class="line">└─main.c</span><br></pre></td></tr></table></figure><p>在<code>src</code>目录中是自定义的头文件</p><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>打开vscode设置，在cmake设置中找到Generator，将其指定为Ninja：</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211210180528993.png" alt="image-20211210180528993"></p><p>CMakeLists.txt文件内容如下</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(Template C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span></span><br><span class="line">        main.c</span><br><span class="line">        src/Template.c</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span> PRIVATE</span><br><span class="line">        src</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>cmake_minimum_required()定义CMake最低版本为3.20</p><p>project()定义项目名称和项目类型</p><p>set(CMAKE_C_STANDARD 23)规定项目使用的C语言标准为C23</p><p>再下面两部分规定了项目包含的源文件以及include文件夹。</p><p>保存文件，会自动生成一个<code>build</code>文件夹。</p><h2 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h2><p>这时候按F5来调试程序，会自动在<code>.vscode</code>目录下生成一个<code>launch.json</code>文件。</p><p>将里面的内容改成如下所示：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;lldb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Debug&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;command:cmake.launchTargetPath&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clangd配置"><a href="#clangd配置" class="headerlink" title="clangd配置"></a>clangd配置</h2><p>打开vscode设置，在扩展中找到clangd，添加如下选项：</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211210180255946.png" alt="image-20211210180255946"></p><ol><li>由于clangd需要读取cmake生成的compile-commands.json文件，所以需要指定其路径</li><li>设置clangd代码提示显示参数类型</li><li>设置从不导入头文件</li></ol><h1 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h1><p>编写简单的测试程序：</p><ul><li>main.c</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Template.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">template</span> x;</span><br><span class="line">    x.a = <span class="number">1</span>;</span><br><span class="line">    x.b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, x.a, x.b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Template.c</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Template.h&quot;</span></span></span><br></pre></td></tr></table></figure><ul><li>Template.h</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125; <span class="keyword">template</span>;</span><br></pre></td></tr></table></figure><p>clangd的代码提示正常，按住ctrl点击头文件可以跳转。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211210180048976.png" alt="image-20211210180048976"></p><p>添加断点调试也没有问题。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211210180732375.png" alt="image-20211210180732375"></p><h1 id="设置运行及调试快捷键"><a href="#设置运行及调试快捷键" class="headerlink" title="设置运行及调试快捷键"></a>设置运行及调试快捷键</h1><p>为了方便运行，可以添加自定义快捷键，实现像code runner插件那样的运行体验。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>按F1，输入cmake，找到运行但不调试，点击右边的齿轮按钮来自定义快捷键。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211210181108443.png" alt="image-20211210181108443"></p><p>点击左边的编辑后输入要绑定的快捷键之后回车，这里就绑定为ctrl+alt+n，跟code runner一样，为了不发生冲突，找到code runner的运行快捷键，右键更改when表达式，填入如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">editorLangId != <span class="string">&#x27;c&#x27;</span> &amp;&amp; editorLangId != <span class="string">&#x27;cpp&#x27;</span></span><br></pre></td></tr></table></figure><p>这样，code runner的快捷键就不会在编写C/C++时生效了。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>默认的调试快捷键为F5，很方便，但为了符合习惯，将其改为ctrl+alt+m，方法同上，这一快捷键与code runner中的停止运行冲突，感觉这个快捷键没什么用，直接删了。</p><p>到此配置完成，源代码编辑完成后可以ctrl+alt+n运行，ctrl+allt+m调试，不影响code runner运行python之类的。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全自动托管青年大学习</title>
      <link href="/2021/11/28/%E5%85%A8%E8%87%AA%E5%8A%A8%E6%89%98%E7%AE%A1%E9%9D%92%E5%B9%B4%E5%A4%A7%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/28/%E5%85%A8%E8%87%AA%E5%8A%A8%E6%89%98%E7%AE%A1%E9%9D%92%E5%B9%B4%E5%A4%A7%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>利用Python自动化完成每期的青年大学习，将python脚本托管到GitHub action并设置定时任务之后即可完全解放双手。</p><span id="more"></span><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>要想自动化地完成这一操作，首先我们得分析当我们在微信上点开青年大学习的时候，后台到底干了什么，这样我们才能知道如何去自动化地完成这一系列动作。我们怎么才能知道呢，抓包看一下嘛，遇事不决，先抓包。</p><p>抓包软件，实际上就是接管你的系统代理，所有数据包都经过这个软件之后，再到原本要去的地方，大概就这个意思。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211128150137836.png" alt="image-20211128150137836"></p><p>所以我们先要准备抓包工具</p><h2 id="安装抓包软件"><a href="#安装抓包软件" class="headerlink" title="安装抓包软件"></a>安装抓包软件</h2><p>我用的是Charles，挺好用的软件，官网下载就好，安装一路点过就好了。</p><h3 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h3><p>软件安装完成后还要安装CA证书，点install一路下一步安装就好</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211128150509163.png" alt="image-20211128150509163"></p><h3 id="安装手机证书"><a href="#安装手机证书" class="headerlink" title="安装手机证书"></a>安装手机证书</h3><p>由于青年大学习必须得用微信完成，大学习的网址用电脑浏览器打开会提示必须用微信打开，单纯的改浏览器UA根本没用，因为青年大学习还要用微信登陆，所以我们抓包的时候用手机操作，然后用Charles查看发送的数据包即可。</p><p>但是现在Charles仅仅接管了电脑的系统代理，不拍，刚刚的选项还有一个，给手机安装证书，点击之后手机与电脑连接统一局域网，然后手机代理设置为手动，代理主机设置为电脑即可。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211128151111456.png" alt="image-20211128151111456"></p><p>按照要求进行操作，代理主机地址就是192.168.5.6，端口8888，每个人都不一样，地址其实就是电脑的内网ip。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211128151154194.png" alt="image-20211128151154194"></p><p>然后按照要求手机访问chls.pro/ssl去下载证书文件，这时候电脑上会有提示，是否允许连接，选择allow即可，下载好证书之后在手机设置，隐私安全之类的里面安装证书即可。</p><p>现在Charles就可以对手机进行抓包了。</p><h1 id="开始抓包"><a href="#开始抓包" class="headerlink" title="开始抓包"></a>开始抓包</h1><p>电脑端保持监听，手机正常操作打开青年大学习，一系列操作之后可以在电脑上看到，手机访问了这个网址：</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211128151816859.png" alt="image-20211128151816859"></p><p>点击开始学习后，在api下的student多了commit，这就是学习是向后台提交的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211128152015847.png" alt="image-20211128152015847"></p><h1 id="编写代码测试"><a href="#编写代码测试" class="headerlink" title="编写代码测试"></a>编写代码测试</h1><h2 id="直接POST"><a href="#直接POST" class="headerlink" title="直接POST"></a>直接POST</h2><p>可以看到，访问类型是POST,直接用python进行测试。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211128152140203.png" alt="image-20211128152140203"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://dxx.scyol.com/api/student/commit&quot;</span></span><br><span class="line">r = requests.post(url)</span><br><span class="line">r.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure><p>运行结果如下，说明还是需要设置UA、token之类的东西。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211128152441287.png" alt="image-20211128152441287"></p><p>观察之前正常操作时发送的commit：</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211128152740705.png" alt="image-20211128152740705"></p><h2 id="添加UA和token"><a href="#添加UA和token" class="headerlink" title="添加UA和token"></a>添加UA和token</h2><p>就用这个UA和token，重新编写代码测试：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://dxx.scyol.com/api/student/commit&quot;</span></span><br><span class="line">agent = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>:</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Linux; Android 10;)XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;</span>,  <span class="comment">#直接复制手机访问的UA</span></span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;token&quot;</span>: <span class="string">&quot;XXXXXXXXXXXXXXX&quot;</span>,  <span class="comment">#直接复制抓包获取到的token</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.post(url, headers=agent)</span><br><span class="line">r.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure><p>再次运行，还是有问题，说明还是缺少东西。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211128153533837.png" alt="image-20211128153533837"></p><p>想到青年大学习开始前还要填写一些信息，但是这些操作并没有涉及到填写信息，再次分析抓包数据，在/api/stages/currentInfo中发现个人信息数据。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211128153811708.png" alt="image-20211128153811708"></p><h2 id="添加json数据"><a href="#添加json数据" class="headerlink" title="添加json数据"></a>添加json数据</h2><p>直接构造data，按照格式填入自己的数据：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://dxx.scyol.com/api/student/commit&quot;</span></span><br><span class="line">agent = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>:</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (Linux; Android 10;)XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;</span>,  <span class="comment">#直接复制手机访问的UA</span></span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="string">&quot;token&quot;</span>: <span class="string">&quot;XXXXXXXXXXXXXXX&quot;</span>,  <span class="comment">#直接复制抓包获取到的token</span></span><br><span class="line">&#125;</span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;tel&#x27;</span>: <span class="string">&#x27;xxxxxxxxxxxxx&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;org&#x27;</span>: <span class="string">&#x27;xxxxxxxxx&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;lastOrg&#x27;</span>: <span class="string">&#x27;xxxxxxxxxx&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;orgName&#x27;</span>: <span class="string">&#x27;xxxxxxxxxxxxx&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;allOrgName&#x27;</span>: <span class="string">&#x27;xxxxxxxxxxxxxxxx&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.post(url, headers=agent, data=json.dumps(data))</span><br><span class="line">r.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure><p>再次运行测试，发现返回结果正常，搞定！</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211128154441692.png" alt="image-20211128154441692"></p><h1 id="利用github-action自动化运行"><a href="#利用github-action自动化运行" class="headerlink" title="利用github action自动化运行"></a>利用github action自动化运行</h1><p>现在虽说可以直接运行完成学习，但是手动运行跟手机上直接操作好像没有什么区别，所以 再次用万能的action：</p><p>编写workflow：</p><p>将编写好的代码保存后上传到github仓库，由于代码中有许多隐私信息，所以创建私有仓库，也可以在公有仓库中用env，但是麻烦，不用！</p><p>在仓库根目录下创建<code>.github</code>文件夹，在里面创建<code>workflow</code>文件夹,再在里面放入<code>.yml</code>文件就可以啦</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">action</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">main</span> ]</span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">cron:</span>  <span class="string">&#x27;00 05 * * *&#x27;</span> <span class="comment"># 每天早上五点自动运行，这里是标准UTC时间，换算之后是北京时间13点运行。</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span>  <span class="comment"># Allow manual triggering</span></span><br><span class="line">    <span class="attr">Scheduled:</span></span><br><span class="line">      <span class="attr">inputs:</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">&#x27;Scheduled Time&#x27;</span>  <span class="comment"># TO-DO</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">qndxx:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Python</span> <span class="number">3.9</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="number">3.9</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        python -m pip install --upgrade pip</span></span><br><span class="line"><span class="string">        pip install requests</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;action&#x27;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        python main.py</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>这个文件会在每天中午一点自动运行，定时设置可以自己修改，一般一周运行两次就好了。</p><h1 id="添加邮件提醒"><a href="#添加邮件提醒" class="headerlink" title="添加邮件提醒"></a>添加邮件提醒</h1><p>每次运行之后结果对不对呢，这点我们没法第一时间知道，我不允许这样的情况出现，所以再次修改Python代码，添加发送邮件功能：</p><p>一般来说自己给自己发，寄件邮箱和收件邮箱用同一个就好了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Send_Email</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    msg = MIMEText(<span class="string">f&#x27;运行返回结果：<span class="subst">&#123;<span class="built_in">str</span>&#125;</span>&#x27;</span>)  <span class="comment"># 构造邮件，内容为青年大学习</span></span><br><span class="line">    msg[<span class="string">&quot;Subject&quot;</span>] = <span class="string">&quot;青年大学习自动化反馈&quot;</span>  <span class="comment"># 设置邮件主题</span></span><br><span class="line">    msg[<span class="string">&quot;From&quot;</span>] = <span class="string">&#x27;action bot&#x27;</span>  <span class="comment"># 寄件者</span></span><br><span class="line">    msg[<span class="string">&quot;To&quot;</span>] = <span class="string">&#x27;xxx&#x27;</span>  <span class="comment"># 收件者</span></span><br><span class="line">    from_addr = <span class="string">&#x27;xxxxxxxxxx@qq.com&#x27;</span></span><br><span class="line">    password = <span class="string">&#x27;xxxxxxxxxxxxxxxx&#x27;</span>  <span class="comment"># 这里用申请的授权码，不是qq邮箱密码。</span></span><br><span class="line">    smtp_server = <span class="string">&#x27;smtp.qq.com&#x27;</span>  <span class="comment"># smtp服务器地址</span></span><br><span class="line">    to_addr = <span class="string">&#x27;xxx@xxx.xxx&#x27;</span>  <span class="comment"># 收件人地址</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server = smtplib.SMTP_SSL(smtp_server, <span class="number">465</span>, timeout=<span class="number">2</span>)</span><br><span class="line">        server.login(from_addr, password)  <span class="comment"># 登录邮箱</span></span><br><span class="line">        server.sendmail(from_addr, to_addr, msg.as_string())</span><br><span class="line">        server.quit()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> e == <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Faild:%s&#x27;</span> % e)</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Send_Email</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    msg = MIMEText(<span class="string">f&#x27;运行返回结果：<span class="subst">&#123;<span class="built_in">str</span>&#125;</span>&#x27;</span>)  <span class="comment"># 构造邮件，内容为青年大学习</span></span><br><span class="line">    msg[<span class="string">&quot;Subject&quot;</span>] = <span class="string">&quot;青年大学习自动化反馈&quot;</span>  <span class="comment"># 设置邮件主题</span></span><br><span class="line">    msg[<span class="string">&quot;From&quot;</span>] = <span class="string">&#x27;action bot&#x27;</span>  <span class="comment"># 寄件者</span></span><br><span class="line">    msg[<span class="string">&quot;To&quot;</span>] = <span class="string">&#x27;xxx&#x27;</span>  <span class="comment"># 收件者</span></span><br><span class="line">    from_addr = <span class="string">&#x27;xxxxxxxxxx@qq.com&#x27;</span></span><br><span class="line">    password = <span class="string">&#x27;xxxxxxxxxxxxxxxx&#x27;</span>  <span class="comment"># 这里用申请的授权码，不是qq邮箱密码。</span></span><br><span class="line">    smtp_server = <span class="string">&#x27;smtp.qq.com&#x27;</span>  <span class="comment"># smtp服务器地址</span></span><br><span class="line">    to_addr = <span class="string">&#x27;xxx@xxx.xxx&#x27;</span>  <span class="comment"># 收件人地址</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server = smtplib.SMTP_SSL(smtp_server, <span class="number">465</span>, timeout=<span class="number">2</span>)</span><br><span class="line">        server.login(from_addr, password)  <span class="comment"># 登录邮箱</span></span><br><span class="line">        server.sendmail(from_addr, to_addr, msg.as_string())</span><br><span class="line">        server.quit()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> e == <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Faild:%s&#x27;</span> % e)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    url = <span class="string">&quot;http://dxx.scyol.com/api/student/commit&quot;</span></span><br><span class="line">    agent = &#123;</span><br><span class="line">            <span class="string">&quot;User-Agent&quot;</span>:</span><br><span class="line">            <span class="string">&quot;Mozilla/5.0 (Linux; Android 10;)XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;</span>,  <span class="comment">#直接复制手机访问的UA</span></span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;token&quot;</span>: <span class="string">&quot;XXXXXXXXXXXXXXX&quot;</span>,  <span class="comment">#直接复制抓包获取到的token</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = &#123;</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;tel&#x27;</span>: <span class="string">&#x27;xxxxxxxxxxxxx&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;org&#x27;</span>: <span class="string">&#x27;xxxxxxxxx&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;lastOrg&#x27;</span>: <span class="string">&#x27;xxxxxxxxxx&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;orgName&#x27;</span>: <span class="string">&#x27;xxxxxxxxxxxxx&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;allOrgName&#x27;</span>: <span class="string">&#x27;xxxxxxxxxxxxxxxx&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    r = requests.post(url, headers=agent, data=json.dumps(data))</span><br><span class="line">    r.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    Send_Email(r.text)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h1><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211128160143876.png" alt="image-20211128160143876"></p>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github+github actions打造完美博客</title>
      <link href="/2021/11/12/hexo-github-github-action%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/11/12/hexo-github-github-action%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>从零开始搭建一个属于自己的功能完备的博客。</p><span id="more"></span><p>之前利用hexo和GitHub Page搭建了博客，博客部署利用的是Travis CI，最近发现github的actions功能跟Travis CI一样，甚至更强大，用起来也特别非常方便，这还用第三方的干嘛，直接迁移到github，顺便重新换个博客主题，从头搭建一下博客。</p><p>github部署博客，利用的是github仓库的page功能，github page只能部署静态网页，虽说有很多限制，但是他免费啊，这样就不用自己租服务器。只能部署静态页面，那就用部署静态博客嘛，用hexo生成不也很方便。</p><h1 id="什么是静态博客"><a href="#什么是静态博客" class="headerlink" title="什么是静态博客"></a>什么是静态博客</h1><p>静态博客就是只有静态页面的博客，什么是静态页面呢，静态页面不是说这个页面不能动，而是说这个网页没有后台，静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件。更新页面就得手动更新html文件，像一些博客的评论功能，这就是典型的动态页面才有的功能，虽说理论上不能用，但总有些奇奇怪怪的办法，这个后面再说。</p><h1 id="静态博客网页生成器"><a href="#静态博客网页生成器" class="headerlink" title="静态博客网页生成器"></a>静态博客网页生成器</h1><p>要搭建静态博客，就得利用静态博客生成器，总不能每篇博文都手写html,这种生成器很多，我用的是比较流行的hexo,还是挺好用的。</p><p>了解了这些就可以开始搭建博客了。</p><h1 id="开始搭建博客"><a href="#开始搭建博客" class="headerlink" title="开始搭建博客"></a>开始搭建博客</h1><h2 id="用到的工具"><a href="#用到的工具" class="headerlink" title="用到的工具"></a>用到的工具</h2><ul><li>git</li><li>nodejs（hexo是基于nodejs,这个必须要装的）</li><li>npm</li></ul><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>windows到git官网下载最新版安装即可。</p><p>linux通过软件包管理工具安装即可。</p><p>git的安装、配置以及基本操作可以看廖雪峰的教程，还是很详细的。<a href="https://www.liaoxuefeng.com/wiki/896043488029600">传送门</a></p><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>nodejs也是安装最新版就好，最新版的nodejs是自带npm的直接可以用。</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>由于npm的下载速度一般都很慢，所以换到淘宝镜像源使用。</p><p>命令行输入以下命令切换淘宝镜像源：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>然后就可以直接用npm安装hexo了，命令行输入以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装完成后就可以开始搭建博客了</p><h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><p>安装好hexo之后就可以用命令来初始化博客了。</p><p>首先命令行转到你要存放博客的文件夹</p><p>然后命令行执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>其中<code>&lt;folder&gt;</code>是你存放博客的文件夹名字。</p><p>这样就新建好了一个博客，现在博客文件夹的目录结构大概是这样的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.     </span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── node_modules                                                     </span><br><span class="line">├── scaffolds</span><br><span class="line">│   ├── draft.md</span><br><span class="line">│   ├── post.md</span><br><span class="line">│   └── page.md</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">│   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>其中<code>_config.yml</code>是博客的配置文件，博客的一些基本设置，都在这里面保存。</p><p>还有<code>package.json</code>和<code>package-lock.json</code>这两个文件是随配置文件自己更新的，不用动他，也不要去动他。</p><p>文件夹<code>node_modules</code>里面存放的是hexo及一些其他模块，也不用动。</p><p>文件夹<code>scaffolds</code>里面放的是文章模板，你新建一片文章的时候实际上就是从这里复制了一份，这里的模板是可以自定义的。</p><p>文件夹<code>source</code>里面放的就是我们的博文了，博文都是用markdown来写的，编辑博文的时候只要编辑source里面的markdown文章即可，hexo可以自动帮你生成并渲染成html页面。</p><p>文件夹<code>theme</code>里面可以放主题文件，hexo官网提供了很多主题可以下载。</p><h2 id="接着对博客进行一些基本设置"><a href="#接着对博客进行一些基本设置" class="headerlink" title="接着对博客进行一些基本设置"></a>接着对博客进行一些基本设置</h2><p>打开编辑<code>_config.yml</code>文件</p><p>各部分配置文件的作用注释都有说明，先改一些基本的设置。</p><p>网站设置</p><table><thead><tr><th align="center">参数</th><th>作用</th></tr></thead><tbody><tr><td align="center"><code>title</code></td><td>网站标题</td></tr><tr><td align="center"><code>subtitle</code></td><td>网站子标题</td></tr><tr><td align="center"><code>description</code></td><td>网站描述</td></tr><tr><td align="center"><code>keywords</code></td><td>关键字</td></tr><tr><td align="center"><code>author</code></td><td>作者</td></tr><tr><td align="center"><code>language</code></td><td>网站语言，简体中文一般设置为zh-CN或zh-Hans</td></tr><tr><td align="center"><code>timezone</code></td><td>网站时区，默认使用电脑的时区，也可以设置为<code>Asia/Shanghai</code></td></tr></tbody></table><h2 id="新建一篇博文"><a href="#新建一篇博文" class="headerlink" title="新建一篇博文"></a>新建一篇博文</h2><p>现在，可以新建一篇博文了，命令行执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post hello_hexo</span><br></pre></td></tr></table></figure><p>执行完成后会发现在<code>source</code>文件夹下的<code>_posts</code>中多了一个叫<code>hello_hexo.md</code>的文件。</p><p>现在打开这个文件开始写点什么。</p><p>新建的文章，打开之后是跟你设置的模板一样的，默认是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211112213425173.png" alt="image-20211112213425173"></p><p>开头这一段是文章的基本信息，在后面接着写博文即可，信息中的<code>tags</code>是文章标签，可以添加一个或多个标签。多个标签用方括号括起来，像这样<code>[tag1,tag2]</code>。</p><h2 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h2><p>写完博客之后，保存文件，然后再命令行执行一下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>执行完成后，hexo便将博文构建成了静态的博客网站，可以发现目录下多了一个叫<code>public</code>的文件夹，这里面就是构建好的静态网站的全部文件，博文更新后可以重新生成，重新生成前先将之前生成的文件清理掉。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>执行完成后，生成的文件就全部清理了，<code>public</code>文件夹不见了，现在就可以重新执行generate来生成了。</p><h2 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h2><p>现在所有文件都还在本地，要想预览博客的样子，可以进行本地部署。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>接着访问默认的4000端口就可以预览博客了。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211112214709481.png" alt="image-20211112214709481"></p>]]></content>
      
      
      <categories>
          
          <category> learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过ESP8266实现远程开关灯</title>
      <link href="/2021/11/11/%E9%80%9A%E8%BF%87ESP8266%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%85%B3%E7%81%AF/"/>
      <url>/2021/11/11/%E9%80%9A%E8%BF%87ESP8266%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%85%B3%E7%81%AF/</url>
      
        <content type="html"><![CDATA[<p>通过ESP8266实现远程开关灯</p><span id="more"></span><h1 id="到货开写"><a href="#到货开写" class="headerlink" title="到货开写"></a>到货开写</h1>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Vivado设置无法保存的问题</title>
      <link href="/2021/10/15/%E8%A7%A3%E5%86%B3Vivado%E8%AE%BE%E7%BD%AE%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2021/10/15/%E8%A7%A3%E5%86%B3Vivado%E8%AE%BE%E7%BD%AE%E6%97%A0%E6%B3%95%E4%BF%9D%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>安装Vivado后使用的过程中发现编辑器默认的字体特别小，还好在设置里面可以改编辑器字体和大小，改完之后看起来好多了。</p><p>但是让人头大的是软件重启之后设置就又恢复默认设置了，设置几遍都一样。</p><span id="more"></span><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在Vivado软件中，在Tools-settings中更改一些设置，关闭软件重新打开后又恢复原状，还注意到原本应该在开始界面显示的最近项目也不会显示。</p><h1 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h1><p>研究了半天终于找到了问题所在。</p><p>原本是想直接改其配置文件让设置来长期保存，找到配置文件后发现原来是因为中文编码的问题。</p><p>在C盘<code>C:\Users\用户名\AppData\Roaming\Xilinx\Vivado\2021.1\</code>下有一个叫<code>vivado.xml</code>的配置文件，保存的就是Vivado的一些设置。</p><p>其中就有一项是最近文件夹，最近项目之类的东西，就是你打开Vivado开始界面显示的最近项目和点打开项目时默认的路径，就像这样。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/3fd75034bef861a9b9272acf48a061c1.png" alt="img"></p><p>前两个是我为了创建项目方便自己加的，后面的是软件自己加的，即使你把它删了，打开软件之后它也会自己加上去，所以2-6这几个路径一定会出现在这里。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211213194901840.png" alt="image-20211213194901840"></p><p>图中的2、4项分别就是快速访问文件夹里面的文档和桌面，3项就是用户目录，一般出问题就出在这里，如果用户名有中文或者快速访问文件夹的路径有中文，在这里就会显示乱码，加载的时候就会出错，然后软件就会把配置文件重置一遍，你之前更改的设置就由变成默认了。</p><p>我就是因为当时把桌面和文档改到D盘的时候在D盘的建的文件夹用了中文导致的问题。</p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>解决办法就是把中文给改了</p><p>用户名的中文改起来特别麻烦，因为牵扯到很多系统变量，建议直接重装系统，一劳永逸。</p><p>快速访问文件夹的路径可以在此电脑对文件夹右健-属性-位置来修改，在D盘新建几个非中文的目录改到那里就好了。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/0a74064c252bcedf943967c8ede83715.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> Vivado </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2021/08/20/Linux/"/>
      <url>/2021/08/20/Linux/</url>
      
        <content type="html"><![CDATA[<p>Linux与Unix可以说是父子关系，学习了Linux，Unix也可以很容易上手，Mac OS是类Unix系统。</p><span id="more"></span><h1 id="1-Linux简介"><a href="#1-Linux简介" class="headerlink" title="1 Linux简介"></a>1 Linux简介</h1><h2 id="1-1-UNIX简介"><a href="#1-1-UNIX简介" class="headerlink" title="1.1 UNIX简介"></a>1.1 UNIX简介</h2><p>Linux与Unix可以说是父子关系，学习了Linux，Unix也可以很容易上手，Mac OS是类Unix系统。</p><h2 id="1-2-Linux简介"><a href="#1-2-Linux简介" class="headerlink" title="1.2 Linux简介"></a>1.2 Linux简介</h2><h3 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h3><p>Linux内核是Linux系统的核心，是有linus与其团队联合开发与管理的，在其官方网站<a href="https://www.kernel.org/">The Linux Kernel Archives</a>发布各个版本的内核，都是开源的，任何人都可以在这内核的基础上进行开发，发布自己的发行版。</p><h3 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h3><p>Linux发行版是各个公司在Linux内核的基础上进行开发发行的操作系统，这些操作系统的底层都是一样的Linux内核，所以都是Linux操作系统，主流的发行版分为两个分支，<code>Readhat</code>和<code>Debian</code>,国内做的比较好的发行版有基于Ubuntu的优麒麟和<code>deepin</code>深度操作系统。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20210819232508265.png" alt="image-20210819232508265"></p><h2 id="1-3-安装Linux"><a href="#1-3-安装Linux" class="headerlink" title="1.3 安装Linux"></a>1.3 安装Linux</h2><h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><p>分区分为主分区、扩展分区，逻辑分区，主分区加扩展分区最多只能有四个，扩展分区最多只能有一个，扩展分区不存储数据，只用来包含逻辑分区，这些限制不是系统的限制，而是硬盘的限制。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20210820001501844.png" alt="image-20210820001501844"></p><p>例如图，1，2，3为主分区，4为扩展分区，5，6为逻辑分区。</p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>硬盘分区后还是不能写入数据，还得进行格式化才可以。</p><p>我们通常所说的格式化是<code>高级格式化</code>，又叫<code>逻辑格式化</code>，它是指用用户指定的<code>文件系统</code>，在磁盘的特定区域写入特定数据用来存储文件目录表，分配表等数据，用来在磁盘中高效地读写数据。</p><p>常见的文件系统：Windows可以识别的文件系统（FAT16,FAT32,NTFS）,Linux可以识别的文件系统（EXT2,EXT3,EXT4）</p><h3 id="硬件设备文件名"><a href="#硬件设备文件名" class="headerlink" title="硬件设备文件名"></a>硬件设备文件名</h3><p>在Windows中，一块硬盘经过分区，格式化之后，只要分配盘符就可以正常使用，但在Linux系统中还需一个步骤，就是建立<code>硬件设备文件名</code>。</p><p>在Linux中有一个概念，所有的硬件都是文件，在Linux的根目录下有一个<code>dev</code>文件夹，这里面存储了所有的硬件设备文件。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20210820002804794.png" alt="image-20210820002804794"></p><p>例如上图中<code>/dev/hda</code>就表示IDE接口的第一块硬盘，<code>/dev/sdb</code>表示SATA接口的第二块硬盘，依次类推。</p><p>除此之外，每块硬盘的每个分区都需要 建立设备文件名，硬盘的分区直接再其后面加数字即可，如<code>/dev/hda1</code>表示IDE接口的第一块硬盘的第一个分区。</p><p>以上这些设备文件名都是固定的，系统自动检测的，不需要自己设置，只需看懂即可。</p><h3 id="分区表示"><a href="#分区表示" class="headerlink" title="分区表示"></a>分区表示</h3><p>比较常用的分区方法</p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20210820003812839.png" alt="image-20210820003812839" style="zoom: 50%;" /><p>分一个主分区，一个扩展分区，其他的全部为逻辑分区，无论有几个主分区，第一个逻辑分区编号一定是5，因为1-4这四个编号只能给主分区和扩展分区使用。另外，分区编号也是系统自动检测的。</p><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>Linux系统中的挂载，相当于Windows系统中的分配盘符，但不同的是，Linux中指定的是挂载点，且有一定要求。</p><p>必须挂载：</p><ul><li><code>/</code>（根目录）</li><li><code>swap</code>（虚拟内存，最多2G即可）</li></ul><p>推荐挂载：</p><ul><li><code>/boot</code>（启动分区，200M足矣）</li></ul><p>给分区挂载好之后分区就可以正常使用了。</p><h3 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>Linux系统的文件系统结构与Windows不同，Windows中的不同盘符是相互独立，相互并列的，在硬盘上也是如此体现，但在Linux中不是这样。</p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20210820004810014.png" alt="image-20210820004810014" style="zoom:33%;" /><p>如图所示是Linux的文件结构，根目录是最高一级目录，其下有一级目录，一级目录下又有二级目录，但与Windows不同的是，比如说<code>/boot</code>是/根目录下的一级目录，但是在硬盘上，<code>/boot</code>是有独立的硬盘空间的，不占<code>/</code>分区的空间。</p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20210820005050748.png" alt="image-20210820005050748" style="zoom:50%;" /><h2 id="1-4-远程管理Linux"><a href="#1-4-远程管理Linux" class="headerlink" title="1.4 远程管理Linux"></a>1.4 远程管理Linux</h2><h3 id="查询-更改IP地址"><a href="#查询-更改IP地址" class="headerlink" title="查询/更改IP地址"></a>查询/更改IP地址</h3><ul><li>查询IP</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ifconfig</span></span><br></pre></td></tr></table></figure><p><code>ifconfig</code>命令可以显示当前机器的所有网卡信息，其中就有IP地址。</p><p>执行效果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.24.134.178  netmask 255.255.240.0  broadcast 172.24.143.255</span><br><span class="line">        inet6 fe80::215:5dff:fee6:971e  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:15:5d:e6:97:1e  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 368  bytes 38952 (38.9 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 13  bytes 1006 (1.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>其中eth0就表示本机的第一块网卡，lo表示本机，如上：<code>172.24.134.178</code>就是本机的IP地址，而<code>127.0.0.1</code>是本地地址，也就是<code>localhost</code></p><ul><li>更改IP地址</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ifconfig eth0 192.168.2.155</span></span><br></pre></td></tr></table></figure><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><p>远程连接服务器时，只要输入正确的IP地址并用正确的用户名密码登录，即可远程管理Linux系统。</p><h2 id="1-5-Linux各目录作用"><a href="#1-5-Linux各目录作用" class="headerlink" title="1.5 Linux各目录作用"></a>1.5 Linux各目录作用</h2><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20210821173605287.png" alt="image-20210821173605287"></p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20210821173520761.png" alt="image-20210821173520761.png"> </p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20210821173820628.png" alt="image-20210821173820628"></p><h1 id="2-Linux基本操作"><a href="#2-Linux基本操作" class="headerlink" title="2 Linux基本操作"></a>2 Linux基本操作</h1><h2 id="2-1-Linux命令格式"><a href="#2-1-Linux命令格式" class="headerlink" title="2.1 Linux命令格式"></a>2.1 Linux命令格式</h2><p>Linux作为一个主要在服务器上运行的操作系统，其强大之处在于它的命令行<code>shell</code>，类似与Windows中的<code>cmd</code>和<code>powershell</code>。学习Linux就是学习<code>shell</code>的基本操作。</p><ul><li><p>Linux命令的基本格式：</p></li><li><p>```shell<br>命令 -[选项] [参数] </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 2.2 Linux常用命令</span><br><span class="line"></span><br><span class="line">### 2.2.1 目录处理命令</span><br><span class="line"></span><br><span class="line">#### 查看所有文件：ls</span><br><span class="line"></span><br><span class="line">- `ls`命令</span><br><span class="line">- 查看当前目录</span><br><span class="line">- 选项：-a(查看所有文件，包括隐藏文件)  -l(显示文件详细信息)  -d(查看目录属性) -i(显示i节点) -h(人性化显示，即智能显示文件大小)</span><br><span class="line">- 格式：ls -[选项] 路径</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">$ ls -l</span><br></pre></td></tr></table></figure></li></ul><p>例如执行该命令可以查看当前目录下所有文件的详细信息。</p><h4 id="切换目录：cd"><a href="#切换目录：cd" class="headerlink" title="切换目录：cd"></a>切换目录：cd</h4><ul><li><code>cd</code> 命令</li><li>切换当前目录</li><li>格式：cd [目录]</li><li>特别的，<code>.</code>表示当前目录，<code>..</code>表示当前目录的上一级目录。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /home/workspace</span></span><br></pre></td></tr></table></figure><p>切换到/home/workspace目录下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure><p>返回上一级目录</p><h4 id="创建目录：mkdir"><a href="#创建目录：mkdir" class="headerlink" title="创建目录：mkdir"></a>创建目录：mkdir</h4><ul><li><code>mkdir</code>命令</li><li>创建目录</li><li>选项：-p(递归创建)</li><li>格式：mkdir -[选项] 目录名称</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir workspace</span></span><br></pre></td></tr></table></figure><p>在当前目录下创建一个workspace目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p worespace/code/python</span></span><br></pre></td></tr></table></figure><p>在当前目录下递归创建多级目录</p><h4 id="显示当前所在目录：pwd"><a href="#显示当前所在目录：pwd" class="headerlink" title="显示当前所在目录：pwd"></a>显示当前所在目录：pwd</h4><ul><li><code>pwd</code>命令</li><li>显示当前所在目录</li></ul><h4 id="删除空目录：rmdir"><a href="#删除空目录：rmdir" class="headerlink" title="删除空目录：rmdir"></a>删除空目录：rmdir</h4><ul><li><code>rmdir</code>命令</li><li>删除空目录</li><li>格式：rmdir [目录]</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rmdir python</span></span><br></pre></td></tr></table></figure><p>注意：该命令只能删除空目录，如果目标目录非空，则会报错。这点限制也导致这一命令基本没什么用。</p><h4 id="复制文件或目录：cp"><a href="#复制文件或目录：cp" class="headerlink" title="复制文件或目录：cp"></a>复制文件或目录：cp</h4><ul><li><code>cp</code>命令</li><li>复制文件或目录</li><li>选项：-r(复制目录) -p(保留文件属性)</li><li>格式：cp -[选项] [原文件或目录] [目标目录]</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp -r /home/workspace/python /home</span></span><br></pre></td></tr></table></figure><p>此外，cp命令还可以在复制的同时进行重命名，只需要在目标目录下写要更改的名字即可，但是感觉这一操作没有必要，既然要复制，为啥还要改名，没什么用。</p><h4 id="剪切-重命名：mv"><a href="#剪切-重命名：mv" class="headerlink" title="剪切/重命名：mv"></a>剪切/重命名：mv</h4><p>Linux下剪切和重命名是同一个命令，由于可以在复制或剪切的同时改名，所以重命名就相当于在将文件剪切到当前目录下的同时改名。</p><ul><li><code>mv</code>命令</li><li>剪切/重命名</li><li>格式：mv [原文件或目录] [目标目录]</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv python /root</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv python java</span></span><br></pre></td></tr></table></figure><h4 id="删除目录或文件：rm"><a href="#删除目录或文件：rm" class="headerlink" title="删除目录或文件：rm"></a>删除目录或文件：rm</h4><p>由于rmdir功能的限制，只能删除空目录，没有什么实际意义，<code>rm</code>命令可以完全替代<code>rmdir</code>命令来进行删除操作。</p><ul><li><code>rm</code>命令</li><li>删除</li><li>选项：-r(删除目录) -f(强制执行)</li><li>格式：rm [选项] [路径]</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm main.c</span></span><br></pre></td></tr></table></figure><p>删除当前目录下的main.c 文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -rf /*</span></span><br></pre></td></tr></table></figure><p>从删库到跑路。。。。</p><h3 id="2-2-2-文件处理命令"><a href="#2-2-2-文件处理命令" class="headerlink" title="2.2.2 文件处理命令"></a>2.2.2 文件处理命令</h3><h4 id="新建文件：touch"><a href="#新建文件：touch" class="headerlink" title="新建文件：touch"></a>新建文件：touch</h4><ul><li><code>touch</code>命令</li><li>新建文件</li><li>格式：touch [文件路径]</li></ul><p>注意，文件名最好不要有空格，否则使用非常麻烦，需要用<code>&quot;&quot;</code>括起来。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch main.py</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch <span class="string">&quot;my java project.java&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="显示文件内容：cat"><a href="#显示文件内容：cat" class="headerlink" title="显示文件内容：cat"></a>显示文件内容：cat</h4><ul><li><code>cat</code>命令</li><li>显示文件内容</li><li>选项：-n(显示行号)</li><li>格式： cat [文件路径]</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat -n /etc/issue</span></span><br><span class="line">1  Ubuntu 20.04.2 LTS \n \l</span><br><span class="line">2</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><h4 id="分页显示文件内容：more-less"><a href="#分页显示文件内容：more-less" class="headerlink" title="分页显示文件内容：more/less"></a>分页显示文件内容：more/less</h4><p>上一条命令<code>cat</code>用来显示短文件没问题，但是特别长的文件，会一直向下拉到最后，只显示最后一屏，中间内容无法查看，这时候就得用<code>more</code>命令。</p><ul><li><code>more</code>命令</li><li>分页显示文件内容</li><li>格式：more [文件路径]</li><li>操作：</li><li><ul><li>翻页：空格或f</li><li>换行：Enter</li><li>退出：q或Q</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> more /etc/services</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Network services, Internet style</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#Note that it is presently the policy of IANA to assign a single well-known</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">port number <span class="keyword">for</span> both TCP and UDP; hence, officially ports have two entries</span></span><br><span class="line"><span class="meta">#</span><span class="bash">even <span class="keyword">if</span> the protocol doesn<span class="string">&#x27;t support UDP operations.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="bash">#Updated from https://www.iana.org/assignments/service-names-port-numbers/service-names-p</span></span></span><br><span class="line"><span class="meta">--More--(2%</span><span class="bash"><span class="string">)</span></span></span><br></pre></td></tr></table></figure><p>可以发现，more命令不支持向上翻页，因此又有一个<code>less</code>命令,操作方法与more一模一样，只不过添加加了<code>page up</code>和<code>up</code>向上翻页的功能。除此之外，<code>less</code>命令还提供了搜索功能，在<code>:</code>后输入<code>/[搜索内容]</code>即可,按<code>n</code>查找下一处。</p><h4 id="显示文件前几行：head"><a href="#显示文件前几行：head" class="headerlink" title="显示文件前几行：head"></a>显示文件前几行：head</h4><ul><li><code>head</code>命令</li><li>显示文件前几行</li><li>格式：head -n [行数] [文件路径]</li></ul><h4 id="显示文件后几行：tail"><a href="#显示文件后几行：tail" class="headerlink" title="显示文件后几行：tail"></a>显示文件后几行：tail</h4><ul><li><code>tail</code>命令</li><li>显示文件后几行</li><li>选项：-f(动态更新末尾内容)</li><li>格式：tail -n [行数] [文件路径]</li></ul><p>注意：head和tail一样，不指定行数时默认为十行，</p><h3 id="2-2-3-链接命令"><a href="#2-2-3-链接命令" class="headerlink" title="2.2.3 链接命令"></a>2.2.3 链接命令</h3><h4 id="生成链接文件：ln"><a href="#生成链接文件：ln" class="headerlink" title="生成链接文件：ln"></a>生成链接文件：ln</h4><ul><li><code>ln</code>命令</li><li>生成链接文件</li><li>选项：-s(生成<code>软链接</code>)</li><li>格式：ln -s [原文件] [目标文件]</li></ul><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>通过实际操作不难发现，软链接非常类似于Windows的快捷方式，软链接文件非常的小，且明确指示了链接导向，这就是软链接的特点。</p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>与软链接不同，硬链接更类似于复制，而且是<code>cp -p</code>的保留文件属性的复制，除此之外，他与复制的不同之处在于，硬链接文件可以与原文件同步更新。而且，即使原文件丢失，硬链接文件依然可以访问。</p><ul><li>硬链接不能跨分区</li><li>硬链接通过i节点来识别</li><li>不能针对目录使用</li></ul><h3 id="2-2-4-权限管理命令"><a href="#2-2-4-权限管理命令" class="headerlink" title="2.2.4 权限管理命令"></a>2.2.4 权限管理命令</h3><h4 id="权限的rwx表示"><a href="#权限的rwx表示" class="headerlink" title="权限的rwx表示"></a>权限的rwx表示</h4><ul><li>r 读取权限</li><li>w 写入权限</li><li>x 执行权限</li></ul><p>在Linux中每个文件对于不同的用户有不同的权限，用户分为三类：</p><ul><li>u 所有者</li><li>g 所属组</li><li>o 其他用户</li></ul><p>所以一个文件的完整权限通常由9个字符表示，如<code>rw-r--r--</code>。</p><h4 id="权限的数字表示"><a href="#权限的数字表示" class="headerlink" title="权限的数字表示"></a>权限的数字表示</h4><ul><li>r—4</li><li>w—2</li><li>x—1</li></ul><p>这样表示之后，每种用户所对应的权限可以用一个数字来表示，如一个文件的权限为741，表示所有者拥有rwx所有权限，所属组拥有rw权限，其他用户拥有x权限。</p><h4 id="改变文件权限：chmod"><a href="#改变文件权限：chmod" class="headerlink" title="改变文件权限：chmod"></a>改变文件权限：chmod</h4><ul><li><code>chmod</code>命令</li><li>改变文件访问权限</li><li>选项：-R(递归修改)(即更改所有子目录及其文件的权限)</li><li>格式：chmod [{ugoa}{+-=}{rwx}] [文件或目录]或chmod [数字权限] [文件或目录]</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod g+w main.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash">给所属组添加w权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod 755 main.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将权限更改为 rwxr-xr-x</span></span><br></pre></td></tr></table></figure><h4 id="改变文件或目录的所有者：chown"><a href="#改变文件或目录的所有者：chown" class="headerlink" title="改变文件或目录的所有者：chown"></a>改变文件或目录的所有者：chown</h4><ul><li><code>chown</code>命令</li><li>改变文件或目录所有者</li><li>格式：chown [用户] [文件或目录]</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chown user1 main.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将main.c文件的所有者改为user1</span></span><br></pre></td></tr></table></figure><h4 id="查看缺省权限：umask"><a href="#查看缺省权限：umask" class="headerlink" title="查看缺省权限：umask"></a>查看缺省权限：umask</h4><p>缺省权限即创建文件或目录时默认的权限，一般目录的缺省权限为rwxr-xr-x,但是对于文件都没有x权限，因此是rw-r–r–。</p><ul><li><code>umask</code>命令</li><li>查看缺省权限</li><li>选项：-S(以rwx格式显示权限)</li><li>格式：umask -S</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span></span></span><br><span class="line">0022</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span> -S</span></span><br><span class="line">u=rwx,g=rx,o=rx</span><br></pre></td></tr></table></figure><h3 id="2-2-5-文件搜索命令"><a href="#2-2-5-文件搜索命令" class="headerlink" title="2.2.5 文件搜索命令"></a>2.2.5 文件搜索命令</h3><h4 id="文件搜索：find"><a href="#文件搜索：find" class="headerlink" title="文件搜索：find"></a>文件搜索：find</h4><ul><li><code>find</code>命令</li><li>搜索文件</li><li>选项：<code>-name</code>(按文件名搜索，*匹配任意字符，？匹配单个字符) <code>-iname</code>(不区分大小写) <code>-size</code>(根据文件大小查找，+表示大于，-表示小于，=表示等于，单位是数据块，一个数据块是0.5k) <code>-user</code>(根据所有者查找) <code>-group</code>(根据所属组查找)  <code>-amin</code>(访问时间，-表示之内)  <code>-cmin</code>(文件属性被修改的时间) <code>-mmin</code>(文件内容被修改的时间) <code>-a</code>(and) <code>-o</code>(or) <code>-type</code>(根据文件类型查找，f文件，d目录，l软链接文件) <code>-ok</code>(对查找结果进行操作，<code>-ok 命令 &#123;&#125;/;</code>) <code>-inum</code>(根据i节点查找)</li><li>格式：find [搜索范围] [选项] [匹配条件]</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find /etc -name *init*</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在/etc目录下查找包含init的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find / -size +204800</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在根目录下查找大于100M的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find / -user root</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在根目录下查找所有者是root的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /home -group root</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在/home目录下查找所属组是root的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find / -amin -5</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在根目录查找5分钟内访问过的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /etc -name *init* -ok ls -l &#123;&#125;\;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在/etc目录下查找包含init的文件并显示详细信息</span></span><br></pre></td></tr></table></figure><h4 id="快速搜索：locate"><a href="#快速搜索：locate" class="headerlink" title="快速搜索：locate"></a>快速搜索：locate</h4><ul><li><code>locate</code>命令</li><li>基于索引快速搜索</li><li>选项：<code>-i</code>(不区分大小写)</li><li>格式：locate [文件名]</li><li>更新索引：<code>updatedb</code></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> locate inittab</span></span><br></pre></td></tr></table></figure><h4 id="查找命令所在目录：which"><a href="#查找命令所在目录：which" class="headerlink" title="查找命令所在目录：which"></a>查找命令所在目录：which</h4><h3 id="2-2-6-帮助命令"><a href="#2-2-6-帮助命令" class="headerlink" title="2.2.6 帮助命令"></a>2.2.6 帮助命令</h3><h4 id="查看命令或配置文件帮助：man"><a href="#查看命令或配置文件帮助：man" class="headerlink" title="查看命令或配置文件帮助：man"></a>查看命令或配置文件帮助：man</h4><ul><li><code>man</code>命令</li><li>查看命令或配置文件帮助</li><li>格式：man [命令或配置文件名称]</li></ul><p>注意，查看配置文件帮助信息时不能写文件的绝对路径，直接写文件名即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> man ls</span></span><br><span class="line">LS(1)                User Commands               LS(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       ls - list directory contents</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       ls [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       List  information  about the FILEs (the current</span><br><span class="line">nual page ls(1) line 1 (press h for help or q to quit)</span><br></pre></td></tr></table></figure><h4 id="查看shell内置命令帮助：help"><a href="#查看shell内置命令帮助：help" class="headerlink" title="查看shell内置命令帮助：help"></a>查看shell内置命令帮助：help</h4><ul><li><code>help</code>命令</li><li>查看shell内置命令帮助</li><li>格式：help [命令]</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">help</span> <span class="built_in">help</span></span></span><br><span class="line">help: help [-dms] [pattern ...]</span><br><span class="line">    Display information about builtin commands.</span><br><span class="line">    Displays brief summaries of builtin commands.  If PATTERN is</span><br><span class="line">    specified, gives detailed help on all commands matching PATTERN,</span><br><span class="line">    otherwise the list of help topics is printed.</span><br><span class="line">    Options:</span><br><span class="line">      -d        output short description for each topic</span><br><span class="line">      -m        display usage in pseudo-manpage format</span><br><span class="line">      -s        output only a short usage synopsis for each topic matching</span><br><span class="line">                PATTERN</span><br><span class="line">    Arguments:</span><br><span class="line">      PATTERN   Pattern specifying a help topic</span><br><span class="line">    Exit Status:</span><br><span class="line">    Returns success unless PATTERN is not found or an invalid option is given.</span><br></pre></td></tr></table></figure><h3 id="2-2-7-用户管理命令"><a href="#2-2-7-用户管理命令" class="headerlink" title="2.2.7 用户管理命令"></a>2.2.7 用户管理命令</h3><h4 id="添加用户：useradd"><a href="#添加用户：useradd" class="headerlink" title="添加用户：useradd"></a>添加用户：useradd</h4><h4 id="设置密码：passwd"><a href="#设置密码：passwd" class="headerlink" title="设置密码：passwd"></a>设置密码：passwd</h4><h3 id="2-2-8-压缩-解压命令"><a href="#2-2-8-压缩-解压命令" class="headerlink" title="2.2.8 压缩-解压命令"></a>2.2.8 压缩-解压命令</h3><h3 id="2-2-9-网络命令"><a href="#2-2-9-网络命令" class="headerlink" title="2.2.9 网络命令"></a>2.2.9 网络命令</h3><h3 id="2-2-10-关机重启命令"><a href="#2-2-10-关机重启命令" class="headerlink" title="2.2.10 关机重启命令"></a>2.2.10 关机重启命令</h3><h4 id="关机重启：shutdown"><a href="#关机重启：shutdown" class="headerlink" title="关机重启：shutdown"></a>关机重启：shutdown</h4><ul><li><code>shutdown</code>命令</li><li>选项：<code>-h</code>(关机) <code>-r</code>(重启) <code>-c</code>(取消前一个命令)</li><li>格式：shutdown [选项] [时间]</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> shutdown -h now</span></span><br><span class="line"><span class="meta">#</span><span class="bash">立即关机</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shutdown -h 20:30</span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置在20:30关机</span></span><br></pre></td></tr></table></figure><h1 id="3-Vim基本操作"><a href="#3-Vim基本操作" class="headerlink" title="3 Vim基本操作"></a>3 Vim基本操作</h1><h3 id="3-1-常用操作"><a href="#3-1-常用操作" class="headerlink" title="3.1 常用操作"></a>3.1 常用操作</h3><h3 id="3-2-使用技巧"><a href="#3-2-使用技巧" class="headerlink" title="3.2 使用技巧"></a>3.2 使用技巧</h3><h1 id="4-软件包管理"><a href="#4-软件包管理" class="headerlink" title="4 软件包管理"></a>4 软件包管理</h1><h1 id="5-shell编程"><a href="#5-shell编程" class="headerlink" title="5 shell编程"></a>5 shell编程</h1>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/2021/07/20/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/20/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Git是一个优秀的版本控制系统，熟练使用Git可以极大地方便我们的工作。</p><span id="more"></span><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>windows下直接在官网下载安装最新版即可，只是安装时记得勾选add to path</p><h3 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h3><p>初次安装git后需要完成一些简单的设置：</p><h4 id="设置用户姓名"><a href="#设置用户姓名" class="headerlink" title="设置用户姓名"></a>设置用户姓名</h4><p><code>git config --global user.name &quot;Your Name&quot;</code></p><h4 id="设置用户邮箱"><a href="#设置用户邮箱" class="headerlink" title="设置用户邮箱"></a>设置用户邮箱</h4><p><code>git config --global user.email &quot;email@example.com&quot;</code></p><p>这两个设置只是为了在多人协作时辨识你的身份，并不是用来登录任何东西，所以随意设置即可。</p><h4 id="生成SSH"><a href="#生成SSH" class="headerlink" title="生成SSH"></a>生成SSH</h4><p>第1步：创建SSH Key。在用户主目录下，看看有没有<code>.ssh</code>目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><p><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></p><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：</p><p>至此，你的SSHkey就添加到了github仓库中，你就可以往远程仓库推送了。</p><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p><code>git init</code>命令可以在当前目录下创建一个版本库。</p><p>命令执行完成后，当前文件夹下会多一个名为<code>.git</code>的文件夹，当然，他是隐藏的，没必要也最好不要去动他。</p><h3 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h3><p><code>git add &lt;file&gt;</code>命令可以将文件添加到暂存区</p><h3 id="提交版本"><a href="#提交版本" class="headerlink" title="提交版本"></a>提交版本</h3><p><code>git commit -m &quot;massage&quot;</code>命令将当前暂存区的所有修改提交到版本库，成为一个新的版本</p><h3 id="查看工作区状态"><a href="#查看工作区状态" class="headerlink" title="查看工作区状态"></a>查看工作区状态</h3><p><code>git status</code>命令可以显示当前工作区的状态</p><h3 id="查看版本提交记录"><a href="#查看版本提交记录" class="headerlink" title="查看版本提交记录"></a>查看版本提交记录</h3><p><code>git log</code>命令可以显示所有提交的版本及其massage，便于查看和回退</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p><code>git reset --hard HEAD^</code> 回退到上一个版本</p><p><code>git reset --hard &lt;版本号&gt;</code> 回退到某一个版本</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用VSCode编辑C51</title>
      <link href="/2021/05/24/%E7%94%A8VSCode%E7%BC%96%E8%BE%91C51/"/>
      <url>/2021/05/24/%E7%94%A8VSCode%E7%BC%96%E8%BE%91C51/</url>
      
        <content type="html"><![CDATA[<p>一般情况下，我们用keil软件编写C51程序，然后通过keil编译生成.hex文件，之后再用STC提供的烧录软件来进行烧录，整个过程非常繁琐，而且keil软件编写代码的体验极差，界面难看不能自定义，代码补全功能也一言难尽。而vscode作为万能的代码编辑器，能否用它来代替keil呢，肯定是可以的。</p><span id="more"></span><h3 id="用到的软件-插件"><a href="#用到的软件-插件" class="headerlink" title="用到的软件/插件"></a>用到的软件/插件</h3><ul><li>vscode</li><li>Embedded IDE(vscode插件):打开keil项目，提供C51代码高亮及自动补全。</li><li>Keil5:虽然是用vscode来进行开发，但是编译还是得用keil里面的编译器。</li><li>stcgal:通过命令行进行烧录<br>通过Python3进行安装：<code>pip install stcgal --user</code></li></ul><h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><p>Embedded IDE可以创建其特有的项目，也可以导入keil项目，要用其编译C51程序，还需要设置编译器路径，只要设置工具链路径为keil安装目录下的TOOL.INI就可以。</p><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211112110234770.png" alt="image-20211112110234770"></p><p>至此，已经可以用vscode开发C51程序，并进行编译了，但是还没法完成烧录，要完成烧录，就需要stcgal了，安装好stcgal之后，在Embedded IDE设置中选择烧录方式为stcgal，使用其默认配置就好。</p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>至此，可以在vscode中完成C51程序的编辑，编译，烧录的一站式开发。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C51 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python访问数据库</title>
      <link href="/2021/05/21/%E4%BD%BF%E7%94%A8Python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2021/05/21/%E4%BD%BF%E7%94%A8Python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>SQLite是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在iOS和Android的App中都可以集成。</p><p>Python就内置了SQLite3，所以，在Python中使用SQLite，不需要安装任何东西，直接使用。</p><span id="more"></span><p>在使用SQLite前，我们先要搞清楚几个概念：</p><p>表是数据库中存放关系数据的集合，一个数据库里面通常都包含多个表，比如学生的表，班级的表，学校的表，等等。表和表之间通过外键关联。</p><p>要操作关系数据库，首先需要连接到数据库，一个数据库连接称为Connection；</p><p>连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果。</p><p>Python定义了一套操作数据库的API接口，任何数据库要连接到Python，只需要提供符合Python标准的数据库驱动即可。</p><p>由于SQLite的驱动内置在Python标准库中，所以我们可以直接来操作SQLite数据库。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入SQLite驱动:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="comment"># 连接到SQLite数据库</span></span><br><span class="line"><span class="comment"># 数据库文件是test.db</span></span><br><span class="line"><span class="comment"># 如果文件不存在，会自动在当前目录创建:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = sqlite3.connect(<span class="string">&#x27;test.db&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建一个Cursor:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor = conn.cursor()</span><br><span class="line"><span class="comment"># 执行一条SQL语句，创建user表:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.execute(<span class="string">&#x27;create table user (id varchar(20) primary key, name varchar(20))&#x27;</span>)</span><br><span class="line">&lt;sqlite3.Cursor <span class="built_in">object</span> at <span class="number">0x10f8aa260</span>&gt;</span><br><span class="line"><span class="comment"># 继续执行一条SQL语句，插入一条记录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.execute(<span class="string">&#x27;insert into user (id, name) values (\&#x27;1\&#x27;, \&#x27;Michael\&#x27;)&#x27;</span>)</span><br><span class="line">&lt;sqlite3.Cursor <span class="built_in">object</span> at <span class="number">0x10f8aa260</span>&gt;</span><br><span class="line"><span class="comment"># 通过rowcount获得插入的行数: </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.rowcount</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># 关闭Cursor:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.close()</span><br><span class="line"><span class="comment"># 提交事务:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.commit()</span><br><span class="line"><span class="comment"># 关闭Connection:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> SQLite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C51单片机编程基础(三)</title>
      <link href="/2021/05/18/C51%E5%8D%95%E7%89%87%E6%9C%BA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%B8%89)/"/>
      <url>/2021/05/18/C51%E5%8D%95%E7%89%87%E6%9C%BA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<p>电机控制</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C51 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C51单片机编程基础(二)</title>
      <link href="/2021/05/17/C51%E5%8D%95%E7%89%87%E6%9C%BA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%BA%8C)/"/>
      <url>/2021/05/17/C51%E5%8D%95%E7%89%87%E6%9C%BA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p>修改点亮led的代码<br>实现led灯的闪烁</p><span id="more"></span><h3 id="实现led灯的闪烁"><a href="#实现led灯的闪烁" class="headerlink" title="实现led灯的闪烁"></a>实现led灯的闪烁</h3><p>首先，要实现闪烁，就需要设计一个延时函数。</p><p>可以用循环来实现</p><p>首先定义数据类型</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br></pre></td></tr></table></figure><h4 id="简单延时函数"><a href="#简单延时函数" class="headerlink" title="简单延时函数"></a>简单延时函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="led闪烁代码"><a href="#led闪烁代码" class="headerlink" title="led闪烁代码"></a>led闪烁代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit led1=P3^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u16;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">(u16 i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        led1=<span class="number">0</span>;</span><br><span class="line">        delay(<span class="number">10000</span>);</span><br><span class="line">        led1=<span class="number">1</span>;</span><br><span class="line">        delay(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过点亮led-延时-关闭led-延时这一流程实现了led的闪烁。</p></blockquote><h4 id="改进优化"><a href="#改进优化" class="headerlink" title="改进优化"></a>改进优化</h4><p>事实上，这一过程还可以优化，在主循环中给led1赋值为1或0可以通过一句按位取反来实现。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    led1=~led1;</span><br><span class="line">    delay(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C51 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C51单片机编程基础(一)</title>
      <link href="/2021/05/17/C51%E5%8D%95%E7%89%87%E6%9C%BA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%B8%80)/"/>
      <url>/2021/05/17/C51%E5%8D%95%E7%89%87%E6%9C%BA%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>从头开始，正经把C51学一遍！<br>完成最简单的C51程序——点亮一个led灯。</p><span id="more"></span><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><h4 id="用到的软件"><a href="#用到的软件" class="headerlink" title="用到的软件"></a>用到的软件</h4><ol><li><blockquote><p>Keil5<br>编写单片机软件部分,将.c文件编译为珂烧录的.hex文件</p></blockquote></li><li><blockquote><p>STC烧录软件<br>将.hex文件通过串口烧录到单片机中</p></blockquote></li><li><blockquote><p>各种驱动如CH340<br>用于驱动串口通信</p></blockquote><h4 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h4></li><li><blockquote><p>51单片机开发板<br>用于烧录后的测试</p></blockquote><h3 id="简单C51编程"><a href="#简单C51编程" class="headerlink" title="简单C51编程"></a>简单C51编程</h3></li></ol><h4 id="点亮一个led灯"><a href="#点亮一个led灯" class="headerlink" title="点亮一个led灯"></a>点亮一个led灯</h4><ul><li>首先引入51的头文件</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;reg52.h&quot;</span></span></span><br></pre></td></tr></table></figure><ul><li>声明led所对应的引脚</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sbit led1 P3^<span class="number">4</span>;</span><br></pre></td></tr></table></figure><ul><li>给led1引脚高电平以点亮led灯</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        led1=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完整程序：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;reg52.h&quot;</span></span></span><br><span class="line">sbit led1=P3^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        led1=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们完成了一个最简单的C51程序，编译，烧录后，就可以看到led被点亮了，再修改程序，把<code>led1=0</code>改为<code>led1=1</code>,再次编译，烧录，可以看到led又灭了。</p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C51 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于githubpages构建失败的原因</title>
      <link href="/2021/05/16/%E5%85%B3%E4%BA%8Egithubpages%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
      <url>/2021/05/16/%E5%85%B3%E4%BA%8Egithubpages%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<p>今天在写了两篇博文后推送到github，hexo的构建顺利通过了，在本地服务器测试也没有任何问题，但是github pages页的build就是会报错，而且没有任何提示，查看<a href="https://docs.github.com/cn/pages/setting-up-a-github-pages-site-with-jekyll/troubleshooting-jekyll-build-errors-for-github-pages-sites#invalid-highlighter-language">官方文档</a>后终于排查到了问题所在。</p><span id="more"></span><p>看到文档所列的问题，第一眼就感觉到是markdown的代码块的问题，因为前一篇文章的latex代码在本地测试时高亮没有问题，但在推送后确没有正常高亮，这就不难发现hexo构建时对代码高亮的处理与markdown不是互通的。</p><p>查看我新发布的两篇博文，一篇中用了 bash 高亮，另一篇用了markdown高亮，鉴于初始文章中用过bash高亮，所以极有可能githubpages不支持markdown的高亮，更改之后，果然构建成功了。</p><p>所以遇到问题查官方文档，总是有点用的</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Next主题下的博文折叠问题</title>
      <link href="/2021/05/16/Next%E4%B8%BB%E9%A2%98%E4%B8%8B%E7%9A%84%E5%8D%9A%E6%96%87%E6%8A%98%E5%8F%A0%E9%97%AE%E9%A2%98/"/>
      <url>/2021/05/16/Next%E4%B8%BB%E9%A2%98%E4%B8%8B%E7%9A%84%E5%8D%9A%E6%96%87%E6%8A%98%E5%8F%A0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在hexo的Next主题下，无论怎样设置，博文都是会全篇显示在首页上，在旧版本的next主题中，可以开启主题配置文件中的摘要，但是新版next主题中并没有这一选项。</p><span id="more"></span><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>要做到把博文折叠，只显示摘要，点击阅读全文后再显示全文，只需要在博文的摘要后加一行<code>&lt;!-- more --&gt;</code>即可，非常方便，效果也很完美。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211112111129708.png" alt="image-20211112111129708"></p><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211112111156797.png" alt="image-20211112111156797"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo和GitHub搭建博客</title>
      <link href="/2021/05/16/hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/05/16/hexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>一直想要利用GitHub Page来搭建一个博客，但是GitHub Page只支持静态页面，没法使用有后台的博客框架，了解之后发现有静态博客框架，大概就是把markdown格式的博文写好之后，一个命令就可以生成html的页面，非常方便，还可以根据自己的喜好进行深度的自定义设置。</p><span id="more"></span><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>hexo是基于node.js的静态博客框架，安装前应该先安装node.js，安装完成后应该是自动安装了npm的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h4 id="hexo基础操作"><a href="#hexo基础操作" class="headerlink" title="hexo基础操作"></a>hexo基础操作</h4><ul><li>初始化Blog</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init &lt;flord&gt;</span><br></pre></td></tr></table></figure><ul><li>新建博文</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new </span><br></pre></td></tr></table></figure><ul><li>生成页面</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><ul><li>本地部署</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex入门</title>
      <link href="/2021/05/15/LaTex%E5%85%A5%E9%97%A8/"/>
      <url>/2021/05/15/LaTex%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>大学生写论文排版真的是太过折磨人，还是LaTex用起来方便一点，不需要学的非常精，只要学点基础的语法，能改模板就好了。</p><span id="more"></span><h3 id="我的LaTex学习笔记"><a href="#我的LaTex学习笔记" class="headerlink" title="我的LaTex学习笔记"></a>我的LaTex学习笔记</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;ctex&#125;%中文支持宏包</span><br><span class="line">\usepackage&#123;graphicx&#125;%图像宏包</span><br><span class="line">\graphicspath&#123;&#123;img/&#125;&#125;</span><br><span class="line">\title&#123; LaTex &#125;</span><br><span class="line">\author&#123;\kaishu 辛巳流火\heiti 辛巳流火&#125;</span><br><span class="line">\date&#123;\heiti &#123;\bfseries 辛巳流火&#125;&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">    \maketitle</span><br><span class="line"></span><br><span class="line">    \section &#123;文本&#125;</span><br><span class="line">        abc \LaTeX 啦啦啦</span><br><span class="line">    \section &#123;公式&#125;</span><br><span class="line">        \subsection&#123;行内公式&#125;$f(x)=a_&#123;b_&#123;c_&#123;d_&#123;e_&#123;f_&#123;g_&#123;h_&#123;i_&#123;j_&#123;k_&#123;l_&#123;m_&#123;n_&#123;o_&#123;p_&#123;q_&#123;r_&#123;s_&#123;t_&#123;u_&#123;v_&#123;w_&#123;x_&#123;y_&#123;z&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;2^&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;-1$</span><br><span class="line"></span><br><span class="line">        \subsection&#123;行间公式&#125;$$f(x)=f(x)^&#123;f(x)^&#123;f(x)&#125;&#125;$$</span><br><span class="line"></span><br><span class="line">        \subsection&#123;带编号行间公式&#125;</span><br><span class="line">        \begin&#123;equation&#125;</span><br><span class="line">            f(x)=x^2-1</span><br><span class="line">        \end&#123;equation&#125;</span><br><span class="line">    \section &#123;引号&#125;</span><br><span class="line">        左单：`左双：``右单：&#x27;右双：&#x27;&#x27;</span><br><span class="line">    \section &#123;连字符&#125;</span><br><span class="line">        -  --  ---</span><br><span class="line">    \section &#123;图像&#125;</span><br><span class="line">       </span><br><span class="line">        \begin&#123;figure&#125;[htbp]%h:此处t:页顶b:页底p:独立一页</span><br><span class="line">            \centering</span><br><span class="line">            \includegraphics[width=10cm]&#123;001.jpg&#125;</span><br><span class="line">            \caption&#123;一张壁纸&#125; \label&#123;lll&#125;</span><br><span class="line">        \end&#123;figure&#125;</span><br><span class="line">        插入一张图像如图\ref&#123;lll&#125;</span><br><span class="line">    \section &#123;表格&#125;</span><br><span class="line">        \begin&#123;tabular&#125;&#123;|l||c|c|c|p&#123;1.5cm&#125;|&#125;</span><br><span class="line">            \hline</span><br><span class="line">            姓名&amp;语文&amp;数学&amp;英语&amp;备注\\</span><br><span class="line">            \hline \hline</span><br><span class="line">            hgy&amp;100&amp;100&amp;100&amp;优秀\\</span><br><span class="line">            \hline</span><br><span class="line"></span><br><span class="line">        \end&#123;tabular&#125;</span><br><span class="line">    \section &#123;粗体&#125;</span><br><span class="line">        第一种\textbf&#123;加粗&#125;方式</span><br><span class="line"></span><br><span class="line">        第二种&#123;\bfseries 加粗&#125;方式</span><br><span class="line">    \section &#123;公式&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python操作Excel文件</title>
      <link href="/2021/05/15/%E4%BD%BF%E7%94%A8Python%E6%93%8D%E4%BD%9CExcel%E6%96%87%E4%BB%B6/"/>
      <url>/2021/05/15/%E4%BD%BF%E7%94%A8Python%E6%93%8D%E4%BD%9CExcel%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>一直看到有用python进行自动化办公的视频，但没有去学习过，正好yby找我帮忙处理一个excel文件，借此机会简单学习一下，简单了解之后发现不是很难，都有现成的库来支持。</p><span id="more"></span><h3 id="用到的库"><a href="#用到的库" class="headerlink" title="用到的库"></a>用到的库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd <span class="comment"># 读取excel库：xlrd</span></span><br><span class="line"><span class="keyword">import</span> xlwt <span class="comment"># 读取excel库：xlwt</span></span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book = xlrd.open_workbook(<span class="string">&#x27;input.xls&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用xlrd中的open_workbook方法打开input.xls</span></span><br><span class="line">sheet1 = book.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># workbook对象的sheet_by_index方法打开第一个工作表，注意这里的索引值是从0开始的</span></span><br></pre></td></tr></table></figure><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>在xlrd中读取excel表格中的指定行列有三种方法：</p><ul><li>row方法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">row_1 = sheet1.row(<span class="number">1</span>).value <span class="comment"># 读取第二行</span></span><br><span class="line">pos_1_0  =sheet1.row(<span class="number">1</span>)[<span class="number">0</span>].value <span class="comment"># 读取第二行的第一个单元格</span></span><br></pre></td></tr></table></figure><ul><li>col方法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col_1 = sheet1.col(<span class="number">1</span>).value <span class="comment"># 读取第二列</span></span><br><span class="line">pos_0_1  =sheet1.col(<span class="number">1</span>)[<span class="number">0</span>].value <span class="comment"># 读取第二列的第一个单元格</span></span><br></pre></td></tr></table></figure><ul><li>cell方法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pos_1_0 = sheet1.cell(<span class="number">1</span>, <span class="number">0</span>).value <span class="comment"># 读取第二行的第一个单元格</span></span><br></pre></td></tr></table></figure><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="comment"># 打开excel文件</span></span><br><span class="line">sheet1 = xlrd.open_workbook(<span class="string">&#x27;123.xls&#x27;</span>).sheet_by_index(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 打开txt文件</span></span><br><span class="line">output = <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, sheet1.nrows):</span><br><span class="line">    <span class="keyword">if</span> sheet1.row(i)[<span class="number">0</span>].value <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]:</span><br><span class="line">        output.write(<span class="string">f&#x27;<span class="subst">&#123;sheet1.row(i)[<span class="number">1</span>].value&#125;</span>:<span class="subst">&#123;sheet1.row(i)[<span class="number">2</span>].value&#125;</span>\n&#x27;</span>)</span><br><span class="line">        output.write(<span class="string">f&#x27;答案：<span class="subst">&#123;<span class="built_in">str</span>(sheet1.row(i)[<span class="number">3</span>].value)&#125;</span>\n&#x27;</span>)</span><br><span class="line">        output.write(<span class="string">f&#x27;A: <span class="subst">&#123;sheet1.row(i)[<span class="number">4</span>].value&#125;</span>\n&#x27;</span>)</span><br><span class="line">        output.write(<span class="string">f&#x27;B: <span class="subst">&#123;sheet1.row(i)[<span class="number">5</span>].value&#125;</span>\n&#x27;</span>)</span><br><span class="line">        output.write(<span class="string">f&#x27;C: <span class="subst">&#123;sheet1.row(i)[<span class="number">6</span>].value&#125;</span>\n&#x27;</span>)</span><br><span class="line">        output.write(<span class="string">f&#x27;D: <span class="subst">&#123;sheet1.row(i)[<span class="number">7</span>].value&#125;</span>\n&#x27;</span>)</span><br><span class="line">        output.write(<span class="string">f&#x27;E: <span class="subst">&#123;sheet1.row(i)[<span class="number">8</span>].value&#125;</span>\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> sheet1.row(i)[<span class="number">0</span>].value == <span class="number">3</span>:</span><br><span class="line">        output.write(<span class="string">f&#x27;<span class="subst">&#123;sheet1.row(i)[<span class="number">1</span>].value&#125;</span>:<span class="subst">&#123;sheet1.row(i)[<span class="number">2</span>].value&#125;</span>\n&#x27;</span>)</span><br><span class="line">        output.write(<span class="string">f&#x27;答案：<span class="subst">&#123;<span class="built_in">str</span>(sheet1.row(i)[<span class="number">3</span>].value)&#125;</span>\n&#x27;</span>)</span><br><span class="line">output.close()</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><ul><li>原excel文件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211112111350937.png" alt="image-20211112111350937"></p><ul><li>输出文件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ambition-echo/img_bed/img/image-20211112110443570.png" alt="image-20211112110443570"></p>]]></content>
      
      
      <categories>
          
          <category> Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
